schema {
  query: Query
  mutation: Mutation
}

"""
AI Act Legal Disclaimer
"""
type AIActLegalDisclaimer {
  text: AiActString!
  title: AiActString!
}

"""
AI Act Assessment Query
"""
type AiActAssessment {
  assistantId: String!
  assistantSurvey: AiActAssistantSurvey!
  identifyRiskInfo: AiActIdentifyRisksInfo!
}

"""
AI Act Assessment Basic System Info
"""
type AiActAssistantSurvey {
  actions: [AiActRecommendedAction!]!
  actionsTitle: AiActString!
  assistantId: String!
  hint: AiActString!
  id: String!
  percentCompleted: Int!
  questions: [AiActQuestion!]!
  riskIndicator: AiActRiskIndicator!
  title: AiActString!
}

"""
AI Act Compliance Area
"""
type AiActComplianceArea {
  description: AiActString!
  id: String!
  mandatory: Boolean!
  title: AiActString!
}

"""
AI Act Identify Risks Info
"""
type AiActIdentifyRisksInfo {
  complianceAreas: [AiActComplianceArea!]!
  legalDisclaimer: AIActLegalDisclaimer!
  title: AiActString!
}

type AiActOption {
  id: String!
  risk: AiActOptionRisk
  title: AiActString!
}

type AiActOptionRisk {
  description: AiActString!
  points: Int!
  riskLevel: String
}

"""
AI Act Questions
"""
type AiActQuestion {
  hint: AiActString!
  id: String!
  notes: String
  options: [AiActOption!]!
  title: AiActString!
  value: String
}

"""
AI Act Checklist Action
"""
type AiActRecommendedAction {
  description: AiActString!
  level: String!
}

"""
AI Act Risk Indicator
"""
type AiActRiskIndicator {
  description: AiActString!
  factors: [AiActString!]!
  level: String!
}

type AiActString {
  de: String!
  en: String!
}

type AiAssistant {
  baseCases: [AiAssistantBaseCase!]!
  createdAt: DateTime!
  description: String
  iconUrl: String
  id: ID!
  languageModel: String
  name: String!
  ownerId: ID!
  participants: [User!]!
  updatedAt: DateTime
  url: String
}

type AiAssistantBaseCase {
  assistant: AiAssistant
  condition: String
  createdAt: DateTime!
  id: ID
  instruction: String
  sequence: Float
  updatedAt: DateTime
}

input AiAssistantInput {
  description: String
  icon: String
  languageModel: String
  name: String!
  url: String
}

input AiBaseCaseInputType {
  condition: String
  id: String
  instruction: String
  sequence: Float
}

type AiConversation {
  assistants: [AiAssistant!]!
  createdAt: DateTime!
  humans: [User!]!
  id: ID!
  messages: [AiConversationMessage!]!
  owner: User!
  ownerId: String!
  participants: [AiConversationParticipant!]!
  updatedAt: DateTime
}

input AiConversationCreateInput {
  assistantIds: [String!]!
  userIds: [String!]!
}

type AiConversationMessage {
  content: String
  conversation: AiConversation
  conversationId: ID!
  createdAt: DateTime!
  hidden: Boolean
  id: ID!
  sender: AiConversationParticipant!
  senderId: ID!
  sequenceNumber: BigInt!
  source: String
  updatedAt: DateTime
}

input AiConversationMessageInput {
  content: String!
  conversationId: String!
  recipientAssistantIds: [String!]!
}

interface AiConversationParticipant {
  assistant: AiAssistant
  assistantId: ID
  conversation: AiConversation
  conversationId: ID!
  id: ID!
  isAssistant: Boolean
  isBot: Boolean!
  isHuman: Boolean
  name: String
  user: User
  userId: ID
}

type AiLibrary {
  crawlers: [AiLibraryCrawler!]!
  createdAt: DateTime!
  description: String
  files: [AiLibraryFile!]!
  filesCount: Int!
  id: ID!
  name: String!
  owner: User!
  ownerId: String!
  participants: [User!]!
  updatedAt: DateTime!
  url: String
}

type AiLibraryCrawler {
  createdAt: DateTime!
  cronJob: AiLibraryCrawlerCronJob
  filesCount: Int!
  id: ID!
  isRunning: Boolean!
  lastRun: AiLibraryCrawlerRun
  maxDepth: Int!
  maxPages: Int!
  runCount: Int!
  runs(skip: Int! = 0, take: Int! = 10): [AiLibraryCrawlerRun!]!
  updatedAt: DateTime!
  url: String!
}

type AiLibraryCrawlerCronJob {
  active: Boolean!
  createdAt: DateTime!
  cronExpression: String
  friday: Boolean!
  hour: Int!
  id: ID!
  minute: Int!
  monday: Boolean!
  saturday: Boolean!
  sunday: Boolean!
  thursday: Boolean!
  tuesday: Boolean!
  updatedAt: DateTime!
  wednesday: Boolean!
}

input AiLibraryCrawlerCronJobInput {
  active: Boolean!
  friday: Boolean!
  hour: Int!
  minute: Int!
  monday: Boolean!
  saturday: Boolean!
  sunday: Boolean!
  thursday: Boolean!
  tuesday: Boolean!
  wednesday: Boolean!
}

input AiLibraryCrawlerInput {
  cronJob: AiLibraryCrawlerCronJobInput
  maxDepth: Int!
  maxPages: Int!
  url: String!
}

type AiLibraryCrawlerRun {
  crawler: AiLibraryCrawler!
  crawlerId: ID!
  endedAt: DateTime
  errorMessage: String
  id: ID!
  runByUserId: ID
  startedAt: DateTime!
  success: Boolean
}

type AiLibraryFile {
  chunks: Int
  createdAt: DateTime!
  dropError: String
  id: ID!
  libraryId: String!
  mimeType: String!
  name: String!
  originUri: String
  processedAt: DateTime
  processingEndedAt: DateTime
  processingErrorAt: DateTime
  processingErrorMessage: String
  processingStartedAt: DateTime
  size: Int
  updatedAt: DateTime
  uploadedAt: DateTime
}

input AiLibraryFileInput {
  libraryId: String!
  mimeType: String!
  name: String!
  originUri: String!
}

input AiLibraryInput {
  description: String
  icon: String
  name: String!
  url: String
}

type AiLibraryUpdate {
  crawlerRun: AiLibraryCrawlerRun
  crawlerRunId: ID
  createdAt: DateTime!
  file: AiLibraryFile
  fileId: ID
  id: ID!
  library: AiLibrary
  libraryId: ID!
  message: String
  success: Boolean!
}

"""
Query result for AI library updates
"""
type AiLibraryUpdateQueryResult {
  count: Int!
  crawlerId: String
  library: AiLibrary!
  libraryId: String!
  skip: Int!
  take: Int!
  updates: [AiLibraryUpdate!]!
}

type AiLibraryUsage {
  assistant: AiAssistant!
  assistantId: ID!
  createdAt: DateTime!
  id: ID!
  library: AiLibrary!
  libraryId: ID!
  updatedAt: DateTime!
  usedFor: String
}

"""
AI Models available in the system
"""
type AiModel {
  baseUrl: String
  modelName: String!
  modelType: String!
  options: [AiModelOption!]
  title: String!
}

"""
Options for AI Models
"""
type AiModelOption {
  key: String!
  value: String!
}

type AssistantParticipant implements AiConversationParticipant {
  assistant: AiAssistant
  assistantId: ID
  conversation: AiConversation
  conversationId: ID!
  id: ID!
  isAssistant: Boolean
  isBot: Boolean!
  isHuman: Boolean
  name: String
  user: User
  userId: ID
}

scalar BigInt

type ChatAnswer {
  answer: String
  notEnoughInformation: Boolean
  sessionId: String
  source: String
}

input ConversationInvitationInput {
  allowDifferentEmailAddress: Boolean!
  allowMultipleParticipants: Boolean!
  email: String!
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

scalar Decimal

type HumanParticipant implements AiConversationParticipant {
  assistant: AiAssistant
  assistantId: ID
  conversation: AiConversation
  conversationId: ID!
  id: ID!
  isAssistant: Boolean
  isBot: Boolean!
  isHuman: Boolean
  name: String
  user: User
  userId: ID
}

type Mutation {
  activateUserProfile(profileId: String!): UserProfile
  addAssistantParticipants(assistantId: String!, userIds: [String!]!): [User!]!
  addConversationParticipants(
    assistantIds: [String!]
    conversationId: String!
    userIds: [String!]
  ): [AiConversationParticipant!]
  addLibraryParticipants(libraryId: String!, userIds: [String!]!): [User!]!
  addLibraryUsage(assistantId: String!, libraryId: String!): AiLibraryUsage
  cancelFileUpload(fileId: String!): Boolean
  chat(question: String!, retrievalFlow: RetrievalFlow, sessionId: String): ChatAnswer
  clearEmbeddedFiles(libraryId: String!): Boolean
  confirmConversationInvitation(conversationId: String!, invitationId: String!): AiConversation
  confirmUserProfile(profileId: String!): UserProfile
  createAiAssistant(name: String!): AiAssistant
  createAiConversation(data: AiConversationCreateInput!): AiConversation
  createAiLibrary(data: AiLibraryInput!): AiLibrary
  createAiLibraryCrawler(data: AiLibraryCrawlerInput!, libraryId: String!): AiLibraryCrawler
  createContactRequest(emailOrPhone: String!, message: String!, name: String!): Boolean!
  createConversationInvitations(conversationId: String!, data: [ConversationInvitationInput!]!): AiConversation
  deleteAiAssistant(assistantId: String!): AiAssistant
  deleteAiConversation(conversationId: String!): AiConversation
  deleteAiConversations(conversationIds: [String!]!): Boolean!
  deleteAiLibrary(id: String!): AiLibrary
  deleteAiLibraryCrawler(id: String!): AiLibraryCrawler
  deleteMessage(messageId: String!): AiConversationMessage
  dropFile(fileId: String!): AiLibraryFile
  dropFiles(libraryId: String!): [AiLibraryFile!]
  hideMessage(messageId: String!): AiConversationMessage
  leaveAiConversation(participantId: String!): AiConversationParticipant
  leaveAssistantParticipant(assistantId: String!): User
  leaveLibraryParticipant(libraryId: String!): User
  login(jwtToken: String!): User
  prepareFile(data: AiLibraryFileInput!): AiLibraryFile
  processFile(fileId: String!): AiLibraryFile
  reProcessFile(fileId: String!): AiLibraryFile
  removeAssistantParticipant(assistantId: String!, userId: String!): User!
  removeConversationParticipant(participantId: String!): AiConversationParticipant
  removeLibraryParticipant(libraryId: String!, userId: String!): User!
  removeLibraryUsage(assistantId: String!, libraryId: String!): AiLibraryUsage
  resetAssessmentAnswers(assistantId: String!): DateTime!
  runAiLibraryCrawler(crawlerId: String!): AiLibraryCrawler
  sendConfirmationMail(confirmationUrl: String!): Boolean
  sendMessage(data: AiConversationMessageInput!): [AiConversationMessage!]!
  unhideMessage(messageId: String!): AiConversationMessage
  updateAiAssistant(data: AiAssistantInput!, id: String!): AiAssistant
  updateAiLibrary(data: AiLibraryInput!, id: String!): AiLibrary
  updateAiLibraryCrawler(data: AiLibraryCrawlerInput!, id: String!): AiLibraryCrawler
  updateAssessmentQuestion(assistantId: String!, notes: String, questionId: String!, value: String): DateTime!
  updateLibraryUsage(id: String!, usedFor: String): AiLibraryUsage
  updateMessage(content: String!, messageId: String!): AiConversationMessage
  updateUserProfile(input: UserProfileInput!, profileId: String!): UserProfile
  upsertAiBaseCases(assistantId: String!, baseCases: [AiBaseCaseInputType!]!): [AiAssistantBaseCase!]
}

type Query {
  aiActAssessment(assistantId: String!): AiActAssessment!
  aiAssistant(assistantId: String!): AiAssistant
  aiAssistants: [AiAssistant!]!
  aiConversation(conversationId: String!): AiConversation
  aiConversationMessages(conversationId: String!): [AiConversationMessage!]
  aiConversations: [AiConversation!]!
  aiLibraries: [AiLibrary!]!
  aiLibrary(libraryId: String!): AiLibrary
  aiLibraryFiles(libraryId: String!): [AiLibraryFile!]
  aiLibraryUpdates(crawlerId: ID, libraryId: ID!, skip: Int = 0, take: Int = 10): AiLibraryUpdateQueryResult!
  aiLibraryUsage(assistantId: String, libraryId: String): [AiLibraryUsage!]!
  aiModels: [AiModel!]!
  user(email: String!): User
  userProfile: UserProfile
  users: [User!]!
  version: String
}

enum RetrievalFlow {
  OnlyLocal
  OnlyWeb
  Parallel
  Sequential
}

type User {
  createdAt: DateTime!
  email: String!
  family_name: String
  given_name: String
  id: ID!
  isAdmin: Boolean!
  lastLogin: DateTime
  name: String
  profile: UserProfile
  registered: Boolean
  updatedAt: DateTime
  username: String!
}

input UserInput {
  email: String!
  family_name: String
  given_name: String
  name: String!
}

type UserProfile {
  activationDate: DateTime
  business: String
  confirmationDate: DateTime
  createdAt: DateTime!
  email: String!
  expiresAt: DateTime
  firstName: String
  freeMessages: Int!
  freeStorage: Int!
  id: ID!
  lastName: String
  position: String
  updatedAt: DateTime
  usedMessages: Int
  usedStorage: Int
  userId: ID!
}

input UserProfileInput {
  business: String
  email: String!
  firstName: String
  freeMessages: Int
  freeStorage: Int
  lastName: String
  position: String
}
