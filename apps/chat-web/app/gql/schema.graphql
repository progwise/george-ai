schema {
  query: Query
  mutation: Mutation
}

type AiAssistant {
  assistantType: AiAssistantType!
  createdAt: DateTime!
  description: String
  icon: String
  id: ID!
  name: String!
  ownerId: ID!
  updatedAt: DateTime
  url: String
}

input AiAssistantInput {
  assistantType: AiAssistantType!
  description: String
  icon: String
  name: String!
  url: String
}

"""
Type of the AiAssistant
"""
enum AiAssistantType {
  CHATBOT
  DOCUMENT_GENERATOR
}

type AiConversation {
  assistants: [AiAssistant!]!
  createdAt: DateTime!
  humans: [User!]!
  id: ID!
  messages: [AiConversationMessage!]!
  participants: [AiConversationParticipant!]!
  updatedAt: DateTime
}

input AiConversationCreateInput {
  assistantIds: [String!]!
  userIds: [String!]!
}

type AiConversationMessage {
  content: String
  conversation: AiConversation
  conversationId: ID!
  createdAt: DateTime!
  id: ID!
  sender: AiConversationParticipant!
  senderId: ID!
  sequenceNumber: BigInt!
  source: String
  updatedAt: DateTime
}

input AiConversationMessageInput {
  content: String!
  conversationId: String!
  recipientAssistantIds: [String!]!
}

interface AiConversationParticipant {
  assistant: AiAssistant
  assistantId: ID
  conversation: AiConversation
  conversationId: ID!
  id: ID!
  isAssistant: Boolean
  isBot: Boolean!
  isHuman: Boolean
  name: String
  user: User
  userId: ID
}

type AiLibrary {
  createdAt: DateTime!
  description: String
  id: ID!
  libraryType: AiLibraryType!
  name: String!
  owner: User
  ownerId: String!
  updatedAt: DateTime
  url: String
}

type AiLibraryFile {
  chunks: Int
  createdAt: DateTime!
  id: ID!
  libraryId: String!
  mimeType: String!
  name: String!
  originUri: String
  processedAt: DateTime
  size: Int
  updatedAt: DateTime
  uploadedAt: DateTime
}

input AiLibraryFileInput {
  libraryId: String!
  mimeType: String!
  name: String!
  originUri: String!
}

input AiLibraryInput {
  description: String
  icon: String
  libraryType: AiLibraryType!
  name: String!
  url: String
}

"""
Type of the AiLibrary
"""
enum AiLibraryType {
  GOOGLE_DRIVE
  POCKETBASE
}

type AiLibraryUsage {
  assistant: AiAssistant
  assistantId: ID!
  createdAt: DateTime!
  id: ID!
  library: AiLibrary
  libraryId: ID!
}

input AiLibraryUsageInput {
  assistantId: String!
  libraryId: String!
  use: Boolean!
}

type AiLibraryUsageResult {
  deletedCount: Int
  usageId: String
}

type AssistantParticipant implements AiConversationParticipant {
  assistant: AiAssistant
  assistantId: ID
  conversation: AiConversation
  conversationId: ID!
  id: ID!
  isAssistant: Boolean
  isBot: Boolean!
  isHuman: Boolean
  name: String
  user: User
  userId: ID
}

scalar BigInt

type ChatAnswer {
  answer: String
  notEnoughInformation: Boolean
  sessionId: String
  source: String
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

scalar Decimal

type HumanParticipant implements AiConversationParticipant {
  assistant: AiAssistant
  assistantId: ID
  conversation: AiConversation
  conversationId: ID!
  id: ID!
  isAssistant: Boolean
  isBot: Boolean!
  isHuman: Boolean
  name: String
  user: User
  userId: ID
}

type Mutation {
  addConversationParticipants(
    assistantIds: [String!]
    conversationId: String!
    userIds: [String!]
  ): [AiConversationParticipant!]
  chat(question: String!, retrievalFlow: RetrievalFlow, sessionId: String): ChatAnswer
  clearEmbeddedFiles(libraryId: String!): Boolean
  createAiAssistant(data: AiAssistantInput!, ownerId: String!): AiAssistant
  createAiConversation(data: AiConversationCreateInput!): AiConversation
  createAiLibrary(data: AiLibraryInput!, ownerId: String!): AiLibrary
  createUser(data: UserInput!, username: String!): User
  deleteAiAssistant(assistantId: String!): AiAssistant
  deleteAiConversation(conversationId: String!): AiConversation
  deleteMessage(messageId: String!): AiConversationMessage
  dropFile(fileId: String!): AiLibraryFile
  login(jwtToken: String!): User
  prepareFile(data: AiLibraryFileInput!): AiLibraryFile
  processFile(fileId: String!): AiLibraryFile
  removeConversationParticipant(id: String!): AiConversationParticipant
  sendMessage(data: AiConversationMessageInput!, userId: String!): [AiConversationMessage!]!
  updateAiAssistant(data: AiAssistantInput!, id: String!): AiAssistant
  updateAiLibrary(data: AiLibraryInput!, id: String!): AiLibrary
  updateLibraryUsage(data: AiLibraryUsageInput!): AiLibraryUsageResult
  updateMessage(content: String!, messageId: String!): AiConversationMessage
}

type Query {
  aiAssistant(id: String!): AiAssistant
  aiAssistants(ownerId: String!): [AiAssistant!]!
  aiConversation(conversationId: String!): AiConversation
  aiConversationMessages(conversationId: String!, userId: String!): [AiConversationMessage!]
  aiConversations(userId: String!): [AiConversation!]!
  aiLibraries(ownerId: String!): [AiLibrary!]
  aiLibrary(id: String!): AiLibrary
  aiLibraryFiles(libraryId: String!): [AiLibraryFile!]
  aiLibraryUsage(assistantId: String, libraryId: String): [AiLibraryUsage!]
  myConversationUsers(userId: String!): [User!]!
  user(email: String!): User
}

enum RetrievalFlow {
  OnlyLocal
  OnlyWeb
  Parallel
  Sequential
}

type User {
  createdAt: DateTime!
  email: String!
  family_name: String
  given_name: String
  id: ID!
  lastLogin: DateTime
  name: String
  updatedAt: DateTime
  username: String!
}

input UserInput {
  email: String!
  family_name: String
  given_name: String
  name: String!
}
