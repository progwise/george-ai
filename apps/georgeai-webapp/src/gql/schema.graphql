schema {
  query: Query
  mutation: Mutation
}

"""
AI Act Legal Disclaimer
"""
type AIActLegalDisclaimer {
  text: AiActString!
  title: AiActString!
}

"""
AI Act Assessment Query
"""
type AiActAssessment {
  assistantId: String!
  assistantSurvey: AiActAssistantSurvey!
  identifyRiskInfo: AiActIdentifyRisksInfo!
}

"""
AI Act Assessment Basic System Info
"""
type AiActAssistantSurvey {
  actions: [AiActRecommendedAction!]!
  actionsTitle: AiActString!
  assistantId: String!
  hint: AiActString!
  id: String!
  percentCompleted: Int!
  questions: [AiActQuestion!]!
  riskIndicator: AiActRiskIndicator!
  title: AiActString!
}

"""
AI Act Compliance Area
"""
type AiActComplianceArea {
  description: AiActString!
  id: String!
  mandatory: Boolean!
  title: AiActString!
}

"""
AI Act Identify Risks Info
"""
type AiActIdentifyRisksInfo {
  complianceAreas: [AiActComplianceArea!]!
  legalDisclaimer: AIActLegalDisclaimer!
  title: AiActString!
}

type AiActOption {
  id: String!
  risk: AiActOptionRisk
  title: AiActString!
}

type AiActOptionRisk {
  description: AiActString!
  points: Int!
  riskLevel: String
}

"""
AI Act Questions
"""
type AiActQuestion {
  hint: AiActString!
  id: String!
  notes: String
  options: [AiActOption!]!
  title: AiActString!
  value: String
}

"""
AI Act Checklist Action
"""
type AiActRecommendedAction {
  description: AiActString!
  level: String!
}

"""
AI Act Risk Indicator
"""
type AiActRiskIndicator {
  description: AiActString!
  factors: [AiActString!]!
  level: String!
}

type AiActString {
  de: String!
  en: String!
}

type AiAssistant {
  baseCases: [AiAssistantBaseCase!]!
  createdAt: DateTime!
  description: String
  iconUrl: String
  id: ID!
  languageModel: AiLanguageModel
  name: String!
  ownerId: ID!
  updatedAt: DateTime
  url: String
  users: [User!]!
}

type AiAssistantBaseCase {
  assistant: AiAssistant
  condition: String
  createdAt: DateTime!
  id: ID
  instruction: String
  sequence: Float
  updatedAt: DateTime
}

input AiAssistantInput {
  description: String
  icon: String
  languageModelId: String
  name: String!
  url: String
}

input AiBaseCaseInputType {
  condition: String
  id: String
  instruction: String
  sequence: Float
}

type AiContentExtractionSubTask {
  contentProcessingTask: AiContentProcessingTask!
  contentProcessingTaskId: String!
  extractionMethod: String!
  failedAt: DateTime
  finishedAt: DateTime
  id: ID!
  markdownFileName: String
  startedAt: DateTime
}

type AiContentProcessingTask {
  chunksCount: Int
  chunksSize: Int
  createdAt: DateTime!
  embeddingFailedAt: DateTime
  embeddingFinishedAt: DateTime
  embeddingModel: AiLanguageModel
  embeddingStartedAt: DateTime
  embeddingStatus: EmbeddingStatus!
  embeddingTimeMs: Int
  embeddingTimeout: Boolean!
  extractionFailedAt: DateTime
  extractionFinishedAt: DateTime
  extractionOptions: String
  extractionStartedAt: DateTime
  extractionStatus: ExtractionStatus!
  extractionSubTasks: [AiContentExtractionSubTask!]!
  extractionTimeMs: Int
  extractionTimeout: Boolean!
  file: AiLibraryFile!
  fileId: String!
  id: ID!
  library: AiLibrary!
  libraryId: String!
  metadata: String
  processingCancelled: Boolean!
  processingFailedAt: DateTime
  processingFinishedAt: DateTime
  processingStartedAt: DateTime
  processingStatus: ProcessingStatus!
  processingTimeMs: Int
  processingTimeout: Boolean!
  timeoutMs: Int
}

type AiConversation {
  assistants: [AiAssistant!]!
  createdAt: DateTime!
  humans: [User!]!
  id: ID!
  messages: [AiConversationMessage!]!
  owner: User!
  ownerId: String!
  participants: [AiConversationParticipant!]!
  updatedAt: DateTime
}

input AiConversationCreateInput {
  assistantIds: [String!]!
  userIds: [String!]!
}

type AiConversationMessage {
  content: String
  conversation: AiConversation
  conversationId: ID!
  createdAt: DateTime!
  hidden: Boolean
  id: ID!
  sender: AiConversationParticipant!
  senderId: ID!
  sequenceNumber: BigInt!
  source: String
  updatedAt: DateTime
}

input AiConversationMessageInput {
  content: String!
  conversationId: String!
  recipientAssistantIds: [String!]!
}

interface AiConversationParticipant {
  assistant: AiAssistant
  assistantId: ID
  conversation: AiConversation
  conversationId: ID!
  id: ID!
  isAssistant: Boolean
  isBot: Boolean!
  isHuman: Boolean
  name: String
  user: User
  userId: ID
}

type AiEnrichmentTask {
  completedAt: DateTime
  error: String
  field: AiListField!
  fieldId: String!
  file: AiLibraryFile!
  fileId: String!
  id: ID!
  list: AiList!
  listId: String!
  metadata: String
  priority: Int!
  processingData: AiEnrichmentTaskProcessingData
  requestedAt: DateTime!
  startedAt: DateTime
  status: EnrichmentStatus!
}

type AiEnrichmentTaskProcessingData {
  input: AiEnrichmentTaskProcessingDataInput
  output: AiEnrichmentTaskProcessingDataOutput
}

type AiEnrichmentTaskProcessingDataInput {
  aiGenerationPrompt: String!
  aiModelName: String!
  aiModelProvider: String
  contextFields: [EnrichmentTaskContextField!]!
  dataType: ListFieldType!
  fileId: String!
  fileName: String!
  libraryEmbeddingModel: String
  libraryEmbeddingModelProvider: String
  libraryId: String!
  libraryName: String!
}

type AiEnrichmentTaskProcessingDataOutput {
  aiInstance: String
  enrichedValue: String
  issues: [String!]!
  messages: [EnrichmentTaskMessage!]!
  similarChunks: [EnrichmentTaskSimilarChunk!]
}

type AiLanguageModel {
  adminNotes: String
  assistantsUsingAsChat: [AiAssistant!]
  canDoChatCompletion: Boolean!
  canDoEmbedding: Boolean!
  canDoFunctionCalling: Boolean!
  canDoVision: Boolean!
  createdAt: DateTime!
  enabled: Boolean!
  id: ID!
  lastUsedAt: DateTime
  librariesUsingAsEmbedding: [AiLibrary!]
  listFieldsUsing: [AiListField!]
  name: String!
  provider: String!
}

"""
Paginated result for AI Language Models
"""
type AiLanguageModelsResult {
  count: Int!
  disabledCount: Int!
  embeddingCount: Int!
  enabledCount: Int!
  models: [AiLanguageModel!]!
  providerCapabilities: [ProviderCapabilityCounts!]!
  providerCount: Int!
  skip: Int!
  take: Int!
}

type AiLibrary {
  autoProcessCrawledFiles: Boolean!
  crawlers: [AiLibraryCrawler!]!
  createdAt: DateTime!
  description: String
  embeddingModel: AiLanguageModel
  embeddingTimeoutMs: Int
  fileConverterOptions: String
  filesCount: Int!
  id: ID!
  name: String!
  ocrModel: AiLanguageModel
  owner: User!
  ownerId: String!
  participants: [AiLibraryParticipant!]!
  updatedAt: DateTime!
  url: String
}

type AiLibraryCrawler {
  allowedMimeTypes: String
  crawlerConfig: String
  createdAt: DateTime!
  cronJob: AiLibraryCrawlerCronJob
  excludePatterns: String
  filesCount: Int!
  id: ID!
  includePatterns: String
  isRunning: Boolean!
  lastRun: AiLibraryCrawlerRun
  libraryId: String!
  maxDepth: Int!
  maxFileSize: Int
  maxPages: Int!
  minFileSize: Int
  runCount: Int!
  runs(skip: Int! = 0, take: Int! = 10): [AiLibraryCrawlerRun!]!
  updatedAt: DateTime!
  uri: String!
  uriType: CrawlerUriType!
}

input AiLibraryCrawlerCredentialsInput {
  boxCustomerId: String
  boxToken: String
  password: String
  sharepointAuth: String
  username: String
}

type AiLibraryCrawlerCronJob {
  active: Boolean!
  createdAt: DateTime!
  cronExpression: String
  friday: Boolean!
  hour: Int!
  id: ID!
  minute: Int!
  monday: Boolean!
  saturday: Boolean!
  sunday: Boolean!
  thursday: Boolean!
  tuesday: Boolean!
  updatedAt: DateTime!
  wednesday: Boolean!
}

input AiLibraryCrawlerCronJobInput {
  active: Boolean!
  friday: Boolean!
  hour: Int!
  minute: Int!
  monday: Boolean!
  saturday: Boolean!
  sunday: Boolean!
  thursday: Boolean!
  tuesday: Boolean!
  wednesday: Boolean!
}

input AiLibraryCrawlerInput {
  allowedMimeTypes: [String!]
  crawlerConfig: String
  cronJob: AiLibraryCrawlerCronJobInput
  excludePatterns: [String!]
  includePatterns: [String!]
  maxDepth: Int!
  maxFileSize: Int
  maxPages: Int!
  minFileSize: Int
  uri: String!
  uriType: CrawlerUriType!
}

type AiLibraryCrawlerRun {
  crawler: AiLibraryCrawler!
  crawlerId: ID!
  endedAt: DateTime
  errorMessage: String
  filteredUpdatesCount(updateTypeFilter: [String!]): Int!
  id: ID!
  runBy: User
  runByUserId: ID
  startedAt: DateTime!
  stoppedByUser: DateTime
  success: Boolean
  updateStats: [UpdateStats!]!
  updates(skip: Int! = 0, take: Int! = 10, updateTypeFilter: [String!]): [AiLibraryUpdate!]!
  updatesCount: Int!
}

type AiLibraryFile {
  archivedAt: DateTime
  availableExtractionMarkdownFileNames: [String!]!
  cache: [AiListItemCache!]!
  crawledByCrawler: AiLibraryCrawler
  crawler: AiLibraryCrawler
  createdAt: DateTime!
  docPath: String
  dropError: String
  embeddingStatus: EmbeddingStatus!
  extractionStatus: ExtractionStatus!
  id: ID!
  isLegacyFile: Boolean!
  lastEmbedding: AiContentProcessingTask
  lastExtraction: AiContentProcessingTask
  lastSuccessfulEmbedding: AiContentProcessingTask
  lastSuccessfulExtraction: AiContentProcessingTask
  lastUpdate: AiLibraryUpdate
  latestExtractionMarkdownFileNames: [String!]!
  library: AiLibrary!
  libraryId: String!
  markdown(markdownFileName: String): MarkdownResult
  mimeType: String!
  name: String!
  originModificationDate: DateTime
  originUri: String
  processingStatus: ProcessingStatus!
  size: Int
  sourceFiles: [SourceFileLink!]!
  status: String!
  supportedExtractionMethods: [String!]!
  taskCount: Int!
  updatedAt: DateTime
  uploadedAt: DateTime
}

input AiLibraryFileInput {
  libraryId: String!
  mimeType: String!
  name: String!
  originModificationDate: DateTime!
  originUri: String!
  size: Int!
}

"""
Query result for AI library files
"""
type AiLibraryFileQueryResult {
  archivedCount: Int!
  count: Int!
  files: [AiLibraryFile!]!
  library: AiLibrary!
  libraryId: String!
  missingChunksCount: Int!
  missingContentExtractionTasksCount: Int!
  showArchived: Boolean
  skip: Int!
  take: Int!
}

enum AiLibraryFileSortOrder {
  createdAtAsc
  createdAtDesc
  fileNameAsc
  fileNameDesc
}

input AiLibraryInput {
  autoProcessCrawledFiles: Boolean
  description: String
  embeddingModelId: String
  embeddingTimeoutMs: Int
  fileConverterOptions: String
  name: String!
  ocrModelId: String
  url: String
}

type AiLibraryParticipant {
  createdAt: DateTime!
  id: ID!
  library: AiLibrary!
  libraryId: String!
  user: User!
  userId: String!
}

type AiLibraryQueryHit {
  docId: String!
  docName: String!
  docPath: String!
  highlights: [AiLibraryQueryHitHighlight!]!
  id: String!
  originUri: String!
  pageContent: String!
}

type AiLibraryQueryHitHighlight {
  field: String!
  snippet: String
}

type AiLibraryQueryResult {
  hitCount: Int!
  hits: [AiLibraryQueryHit!]!
  libraryId: String!
  query: String!
  skip: Int!
  take: Int!
}

type AiLibraryUpdate {
  crawlerRun: AiLibraryCrawlerRun
  crawlerRunId: ID
  createdAt: DateTime!
  file: AiLibraryFile
  fileId: ID
  fileName: String
  filePath: String
  fileSize: Int
  filterType: String
  filterValue: String
  id: ID!
  library: AiLibrary
  libraryId: ID!
  message: String
  updateType: String!
}

"""
Query result for AI library updates
"""
type AiLibraryUpdateQueryResult {
  count: Int!
  crawlerId: String
  library: AiLibrary!
  libraryId: String!
  skip: Int!
  take: Int!
  updates: [AiLibraryUpdate!]!
}

type AiLibraryUsage {
  assistant: AiAssistant!
  assistantId: ID!
  createdAt: DateTime!
  id: ID!
  library: AiLibrary!
  libraryId: ID!
  updatedAt: DateTime!
  usedFor: String
}

type AiList {
  createdAt: DateTime!
  enrichmentTasks: [AiEnrichmentTask!]!
  fields: [AiListField!]!
  id: ID!
  name: String!
  owner: User!
  ownerId: String!
  participants: [AiListParticipant!]!
  sources: [AiListSource!]!
  updatedAt: DateTime
}

type AiListField {
  context: [AiListFieldContext!]!
  contextFieldReferences: [AiListFieldContext!]!
  contextVectorSearches: [AiListFieldContext!]!
  contextWebFetches: [AiListFieldContext!]!
  failureTerms: String
  fileProperty: String
  id: ID!
  languageModel: AiLanguageModel
  list: AiList!
  listId: String!
  name: String!
  order: Int!
  pendingItemsCount: Int!
  processingItemsCount: Int!
  prompt: String
  sourceType: ListFieldSourceType!
  type: ListFieldType!
}

type AiListFieldContext {
  contextField: AiListField
  contextFieldId: String
  contextQuery: String
  contextType: ListFieldContextType!
  createdAt: DateTime!
  field: AiListField!
  fieldId: String!
  id: ID!
  maxContentTokens: Int
}

input AiListFieldContextInput {
  contextFieldId: String
  contextQuery: String
  contextType: ListFieldContextType!
  maxContentTokens: Int
}

input AiListFieldInput {
  contextSources: [AiListFieldContextInput!]
  failureTerms: String
  fileProperty: String
  languageModelId: String
  name: String!
  order: Int
  prompt: String
  """
  Source type: file_property or llm_computed
  """
  sourceType: ListFieldSourceType!
  """
  Field type: string, text, number, date, datetime, boolean
  """
  type: ListFieldType!
}

type AiListFieldStatistics {
  cacheCount: Int!
  completedTasksCount: Int!
  errorTasksCount: Int!
  failedTasksCount: Int!
  fieldId: String!
  fieldName: String!
  itemCount: Int!
  listId: String!
  pendingTasksCount: Int!
  processingTasksCount: Int!
  valuesCount: Int!
}

input AiListFilterInput {
  fieldId: String!
  filterType: AiListFilterType!
  value: String!
}

enum AiListFilterType {
  contains
  ends_with
  equals
  is_empty
  is_not_empty
  not_contains
  not_equals
  starts_with
}

input AiListInput {
  name: String!
}

type AiListItemCache {
  enrichmentErrorMessage: String
  fieldId: String!
  id: ID!
  valueBoolean: Boolean
  valueDate: DateTime
  valueNumber: Float
  valueString: String
}

type AiListParticipant {
  id: ID!
  list: AiList!
  listId: String!
  user: User!
  userId: String!
}

enum AiListSortingDirection {
  asc
  desc
}

input AiListSortingInput {
  direction: AiListSortingDirection!
  fieldId: String!
}

type AiListSource {
  createdAt: DateTime!
  id: ID!
  library: AiLibrary
  libraryId: String
  listId: String!
}

input AiListSourceInput {
  libraryId: String!
}

type AiModelInfo {
  capabilities: [String!]!
  digest: String
  family: String
  name: String!
  parameterSize: String
  quantizationLevel: String
  size: Float!
}

type AiModelQueue {
  estimatedRequestSize: Float!
  maxConcurrency: Int!
  modelName: String!
  queueLength: Int!
}

type AiRunningModel {
  activeRequests: Int!
  expiresAt: String!
  name: String!
  size: Float!
}

type AiServiceClusterStatus {
  availableInstances: Int!
  healthyInstances: Int!
  instances: [AiServiceInstance!]!
  totalInstances: Int!
  totalMaxConcurrency: Int!
  totalMemory: Float!
  totalQueueLength: Int!
  totalUsedMemory: Float!
}

type AiServiceInstance {
  availableModels: [AiModelInfo!]
  isOnline: Boolean!
  modelQueues: [AiModelQueue!]
  name: String!
  runningModels: [AiRunningModel!]
  totalVram: Float!
  type: String!
  url: String!
  usedVram: Float!
  version: String!
}

type AiServiceProvider {
  apiKeyHint: String
  baseUrl: String
  createdAt: DateTime!
  createdBy: String
  enabled: Boolean!
  id: ID!
  name: String!
  provider: String!
  updatedAt: DateTime!
  updatedBy: String
  vramGb: Int
  workspace: Workspace!
  workspaceId: String!
}

input AiServiceProviderInput {
  apiKey: String
  baseUrl: String
  enabled: Boolean
  name: String!
  provider: String!
  vramGb: Int
}

type ApiCrawlerTemplate {
  config: String!
  description: String!
  id: String!
  name: String!
}

type ApiKey {
  createdAt: DateTime!
  id: ID!
  lastUsedAt: DateTime
  library: AiLibrary!
  libraryId: String!
  name: String!
  user: User!
  userId: String!
}

type ApiKeyWithSecret {
  createdAt: DateTime!
  id: ID!
  key: String!
  libraryId: String!
  name: String!
}

type AssistantParticipant implements AiConversationParticipant {
  assistant: AiAssistant
  assistantId: ID
  conversation: AiConversation
  conversationId: ID!
  id: ID!
  isAssistant: Boolean
  isBot: Boolean!
  isHuman: Boolean
  name: String
  user: User
  userId: ID
}

scalar BigInt

"""
Result of checking for files by origin URI prefix
"""
type CheckFileExistsByOriginUriResult {
  count: Int!
  originUriPrefix: String!
}

type ComputeFieldValueResult {
  error: String
  success: Boolean
  value: String
}

type ContentExtractionTaskQueryResult {
  count: Int!
  fileId: String
  libraryId: String!
  skip: Int!
  status: ProcessingStatus
  """
  Counts of tasks in each processing state
  """
  statusCounts: [ProcessingTaskStateCount!]!
  take: Int!
  tasks: [AiContentProcessingTask!]!
}

type ContentQueryResult {
  contentQuery: String
  fieldId: String!
  fieldName: String!
  id: String!
  listId: String!
  listName: String!
}

input ConversationInvitationInput {
  allowDifferentEmailAddress: Boolean!
  allowMultipleParticipants: Boolean!
  email: String!
}

enum ConversationSortOrder {
  createdAtAsc
  createdAtDesc
  updatedAtAsc
  updatedAtDesc
}

enum CrawlerUriType {
  api
  box
  http
  sharepoint
  smb
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

scalar Decimal

enum EmbeddingStatus {
  completed
  failed
  none
  pending
  running
  skipped
}

type EnrichmentQueueResult {
  enrichments: [AiEnrichmentTask!]!
  fieldId: String
  fileId: String
  listId: String
  skip: Int
  status: EnrichmentStatus
  statusCounts: [EnrichmentStatusCount!]!
  take: Int
  totalCount: Int!
}

type EnrichmentQueueTasksMutationResult {
  cleanedUpEnrichmentsCount: Int
  cleanedUpTasksCount: Int
  createdTasksCount: Int
}

enum EnrichmentStatus {
  canceled
  completed
  error
  failed
  pending
  processing
}

type EnrichmentStatusCount {
  count: Int!
  status: EnrichmentStatus!
}

type EnrichmentTaskContextField {
  errorMessage: String
  fieldId: String!
  fieldName: String!
  value: String
}

type EnrichmentTaskMessage {
  content: String!
  role: String!
}

type EnrichmentTaskSimilarChunk {
  distance: Float!
  fileId: String!
  fileName: String!
  id: String!
  text: String!
}

enum ExtractionStatus {
  completed
  failed
  none
  pending
  running
  skipped
}

type FieldValueResult {
  displayValue: String
  enrichmentErrorMessage: String
  failedEnrichmentValue: String
  fieldId: String!
  fieldName: String!
  fieldType: String!
  queueStatus: String
}

type FileChunk {
  chunkIndex: Int!
  distance: Float
  fileId: String
  fileName: String
  headingPath: String!
  id: String!
  originUri: String
  points: Int
  section: String!
  subChunkIndex: Int!
  text: String!
}

type FileChunkQueryResponse {
  chunks: [FileChunk!]!
  count: Int!
  fileId: String!
  fileName: String
  libraryId: String!
  skip: Int!
  take: Int!
}

type HumanParticipant implements AiConversationParticipant {
  assistant: AiAssistant
  assistantId: ID
  conversation: AiConversation
  conversationId: ID!
  id: ID!
  isAssistant: Boolean
  isBot: Boolean!
  isHuman: Boolean
  name: String
  user: User
  userId: ID
}

type LibraryCrawlerRunQueryResults {
  count: Int!
  runs: [AiLibraryCrawlerRun!]!
}

enum LibrarySortOrder {
  createdAtAsc
  createdAtDesc
  nameAsc
  nameDesc
  updatedAtAsc
  updatedAtDesc
}

enum ListFieldContextType {
  fieldReference
  vectorSearch
  webFetch
}

enum ListFieldFileProperty {
  crawlerUrl
  lastUpdate
  mimeType
  name
  originModificationDate
  originUri
  processedAt
  size
  source
}

enum ListFieldSourceType {
  file_property
  llm_computed
}

enum ListFieldType {
  boolean
  date
  datetime
  markdown
  number
  string
  text
}

type ListItemQueryResult {
  origin: ListItemResult!
  values: [FieldValueResult!]!
}

type ListItemResult {
  archivedAt: DateTime
  createdAt: DateTime!
  docPath: String
  dropError: String
  id: ID!
  libraryId: String!
  libraryName: String!
  mimeType: String!
  name: String!
  originModificationDate: DateTime
  originUri: String
  size: Int
  type: String!
  updatedAt: DateTime
  uploadedAt: DateTime
}

"""
Query result for AI list files from all source libraries
"""
type ListItemsQueryResult {
  count: Int!
  items: [ListItemQueryResult!]!
  showArchived: Boolean
  skip: Int!
  take: Int!
  unfilteredCount: Int!
}

type ManagedUser {
  activationDate: DateTime
  avatarUrl: String
  business: String
  confirmationDate: DateTime
  createdAt: DateTime!
  email: String!
  family_name: String
  given_name: String
  id: ID!
  isAdmin: Boolean!
  lastLogin: DateTime
  name: String
  position: String
  registered: Boolean
  updatedAt: DateTime
  username: String!
}

type ManagedUsersResponse {
  filter: String
  skip: Int!
  statusFilter: String
  take: Int!
  userStatistics: UserStatistic!
  users: [ManagedUser!]!
}

type MarkdownResult {
  content: String!
  fileName: String!
}

type ModelUsageByType {
  totalRequests: Int!
  totalTokensInput: Int!
  totalTokensOutput: Int!
  usageType: String!
}

type ModelUsageStats {
  avgDurationMs: Float!
  avgTokensInput: Float!
  avgTokensOutput: Float!
  totalDurationMs: Int!
  totalRequests: Int!
  totalTokensInput: Int!
  totalTokensOutput: Int!
}

type Mutation {
  activateUserProfile(profileId: String!): UserProfile
  addAssistantParticipants(assistantId: String!, userIds: [String!]!): [User!]!
  addConversationParticipants(
    assistantIds: [String!]
    conversationId: String!
    userIds: [String!]
  ): [AiConversationParticipant!]
  addLibraryUsage(assistantId: String!, libraryId: String!): AiLibraryUsage
  addListField(data: AiListFieldInput!, listId: String!): AiListField!
  addListSource(data: AiListSourceInput!, listId: String!): AiListSource!
  cancelContentProcessingTasks(libraryId: String): QueueOperationResult!
  cancelFileUpload(fileId: String!): Boolean!
  cancelProcessingTask(fileId: String!, taskId: String!): AiContentProcessingTask!
  clearEmbeddedFiles(libraryId: String!): Boolean
  clearFailedTasks(libraryId: String, queueType: QueueType!): QueueOperationResult!
  clearListEnrichments(
    """
    Optional Field ID to only clean enrichments for a specific field
    """
    fieldId: String
    """
    Optional File ID to only clean enrichments for a specific file
    """
    fileId: String
    """
    List ID to clean enrichments for. Without additional arguments it will clean all enriched values from all fields and items in the list
    """
    listId: String!
  ): EnrichmentQueueTasksMutationResult!
  clearPendingTasks(libraryId: String, queueType: QueueType!): QueueOperationResult!
  computeFieldValue(fieldId: String!, fileId: String!): ComputeFieldValueResult
  confirmConversationInvitation(conversationId: String!, invitationId: String!): AiConversation
  confirmUserProfile(profileId: String!): UserProfile
  createAiAssistant(name: String!): AiAssistant
  createAiConversation(data: AiConversationCreateInput!): AiConversation
  createAiLibraryCrawler(
    credentials: AiLibraryCrawlerCredentialsInput
    data: AiLibraryCrawlerInput!
    libraryId: String!
  ): AiLibraryCrawler!
  createAiServiceProvider(data: AiServiceProviderInput!): AiServiceProvider!
  createContentProcessingTask(fileId: String!): AiContentProcessingTask!
  createConversationInvitations(conversationId: String!, data: [ConversationInvitationInput!]!): AiConversation
  createEmbeddingTask(existingTaskId: String, fileId: String!): AiContentProcessingTask!
  createEnrichmentTasks(
    """
    Field ID to enrich
    """
    fieldId: String!
    """
    Optional File ID to only create task for a specific file
    """
    fileId: String
    filters: [AiListFilterInput!]
    listId: String!
    """
    Only create tasks for files that do not yet have a cached value for this field
    """
    onlyMissingValues: Boolean = true
  ): EnrichmentQueueTasksMutationResult!
  createLibrary(data: AiLibraryInput!): AiLibrary
  createList(data: AiListInput!): AiList!
  createMissingContentExtractionTasks(libraryId: String!): [AiContentProcessingTask!]!
  createWorkspace(name: String!, slug: String!): Workspace!
  deleteAiAssistant(assistantId: String!): AiAssistant
  deleteAiConversation(conversationId: String!): AiConversation
  deleteAiConversations(conversationIds: [String!]!): Boolean!
  deleteAiLibraryCrawler(id: String!): AiLibraryCrawler
  deleteAiServiceProvider(id: ID!): Boolean!
  deleteLibrary(id: String!): AiLibrary!
  deleteLibraryFile(fileId: String!): AiLibraryFile!
  deleteLibraryFiles(fileIds: [ID!]!): Int!
  deleteList(id: String!): AiList!
  deleteMessage(messageId: String!): AiConversationMessage
  deletePendingEnrichmentTasks(
    """
    Field ID to stop enrichment for
    """
    fieldId: String
    """
    File ID to stop enrichment for
    """
    fileId: String
    """
    List ID to stop enrichment for
    """
    listId: String!
  ): EnrichmentQueueTasksMutationResult!
  deleteWorkspace(workspaceId: String!): Boolean!
  disableAiLanguageModel(id: ID!): AiLanguageModel
  dropAllLibraryFiles(libraryId: String!): Int!
  dropOutdatedMarkdowns(fileId: String!): Int!
  dropPendingTasks(libraryId: String!): Int!
  ensureUserProfile(userId: String!): UserProfile
  generateApiKey(libraryId: String!, name: String!): ApiKeyWithSecret!
  hideMessage(messageId: String!): AiConversationMessage
  leaveAiConversation(participantId: String!): AiConversationParticipant
  leaveAssistantParticipant(assistantId: String!): User
  login(jwtToken: String!): User!
  prepareFileUpload(data: AiLibraryFileInput!): AiLibraryFile!
  removeAssistantParticipant(assistantId: String!, userId: String!): User!
  removeConversationParticipant(participantId: String!): AiConversationParticipant
  removeLibraryParticipant(libraryId: String!, participantId: String!): Boolean!
  removeLibraryUsage(assistantId: String!, libraryId: String!): AiLibraryUsage
  removeListField(id: String!): AiListField!
  removeListParticipant(listId: String!, participantId: String!): Boolean!
  removeListSource(id: String!): AiListSource!
  reorderListFields(fieldId: String!, newPlace: Int!): [AiListField!]!
  resetAssessmentAnswers(assistantId: String!): DateTime!
  restoreDefaultProviders: RestoreDefaultProvidersResult!
  retryFailedTasks(libraryId: String, queueType: QueueType!): QueueOperationResult!
  revokeApiKey(id: String!): Boolean!
  runAiLibraryCrawler(crawlerId: String!): String!
  sendConfirmationMail(activationUrl: String!, confirmationUrl: String!): Boolean
  sendMessage(data: AiConversationMessageInput!): [AiConversationMessage!]!
  startAllQueueWorkers: QueueOperationResult!
  startQueueWorker(queueType: QueueType!): QueueOperationResult!
  stopAiLibraryCrawler(crawlerId: String!): String!
  stopAllQueueWorkers: QueueOperationResult!
  stopQueueWorker(queueType: QueueType!): QueueOperationResult!
  syncModels: SyncModelsResult
  testProviderConnection(data: TestProviderConnectionInput!): TestProviderConnectionResult!
  toggleAdminStatus(userId: String!): User
  toggleAiServiceProvider(enabled: Boolean!, id: ID!): AiServiceProvider!
  unhideMessage(messageId: String!): AiConversationMessage
  updateAiAssistant(data: AiAssistantInput!, id: String!): AiAssistant
  updateAiLanguageModel(data: UpdateAiLanguageModelInput!, id: ID!): AiLanguageModel
  updateAiLibraryCrawler(
    credentials: AiLibraryCrawlerCredentialsInput
    data: AiLibraryCrawlerInput!
    id: String!
  ): AiLibraryCrawler!
  updateAiServiceProvider(data: AiServiceProviderInput!, id: ID!): AiServiceProvider!
  updateAssessmentQuestion(assistantId: String!, notes: String, questionId: String!, value: String): DateTime!
  updateLibrary(data: AiLibraryInput!, id: String!): AiLibrary!
  updateLibraryParticipants(libraryId: String!, userIds: [String!]!): UpdateLibraryParticipantsResult!
  updateLibraryUsage(id: String!, usedFor: String): AiLibraryUsage
  updateList(data: AiListInput!, id: String!): AiList
  updateListField(data: AiListFieldInput!, id: String!): AiListField!
  updateListParticipants(listId: String!, userIds: [String!]!): UpdateListParticipantsResult!
  updateMessage(content: String!, messageId: String!): AiConversationMessage
  updateUserAvatar(avatarUrl: String): User
  updateUserProfile(input: UserProfileInput!, profileId: String!): UserProfile
  upsertAiBaseCases(assistantId: String!, baseCases: [AiBaseCaseInputType!]!): [AiAssistantBaseCase!]
  validateSharePointConnection(sharepointAuth: String!, uri: String!): SharePointValidationResult!
  validateWorkspaceDeletion(workspaceId: String!): WorkspaceDeletionValidation!
}

enum ProcessingStatus {
  cancelled
  completed
  embedding
  embeddingFailed
  embeddingFinished
  extracting
  extractionFailed
  extractionFinished
  failed
  none
  pending
  timedOut
  validating
  validationFailed
}

type ProcessingTaskStateCount {
  count: Int!
  status: ProcessingStatus!
}

type ProviderCapabilityCounts {
  chatCount: Int!
  disabledCount: Int!
  embeddingCount: Int!
  enabledCount: Int!
  functionCount: Int!
  modelCount: Int!
  provider: String!
  visionCount: Int!
}

type Query {
  aiActAssessment(assistantId: String!): AiActAssessment!
  aiAssistant(assistantId: String!): AiAssistant
  aiAssistants: [AiAssistant!]!
  aiContentProcessingTasks(
    fileId: String
    libraryId: String!
    skip: Int = 0
    status: ProcessingStatus
    take: Int = 20
  ): ContentExtractionTaskQueryResult!
  aiContentQueries(libraryId: String, listId: String): [ContentQueryResult!]!
  aiConversation(conversationId: String!): AiConversation
  aiConversationMessages(conversationId: String!): [AiConversationMessage!]
  aiConversations(orderBy: ConversationSortOrder): [AiConversation!]!
  aiFileChunks(fileId: String!, skip: Int!, take: Int!): FileChunkQueryResponse!
  aiLanguageModels(
    canDoChatCompletion: Boolean
    canDoEmbedding: Boolean
    canDoFunctionCalling: Boolean
    canDoVision: Boolean
    onlyUsed: Boolean = false
    providers: [String!]
    search: String
    showDisabled: Boolean = false
    skip: Int = 0
    take: Int = 20
  ): AiLanguageModelsResult!
  aiLibraries(orderBy: LibrarySortOrder): [AiLibrary!]!
  aiLibrary(libraryId: String!): AiLibrary!
  aiLibraryCrawler(crawlerId: String!, libraryId: String!): AiLibraryCrawler!
  aiLibraryCrawlerRun(crawlerRunId: String!, libraryId: String!): AiLibraryCrawlerRun!
  aiLibraryCrawlerRuns(
    crawlerId: String
    libraryId: String!
    skip: Int = 0
    take: Int = 20
  ): LibraryCrawlerRunQueryResults!
  aiLibraryFile(fileId: String!): AiLibraryFile!
  aiLibraryFiles(
    libraryId: String!
    orderBy: AiLibraryFileSortOrder = createdAtDesc
    showArchived: Boolean = false
    skip: Int! = 0
    take: Int! = 20
  ): AiLibraryFileQueryResult!
  aiLibraryUpdates(crawlerId: ID, libraryId: ID!, skip: Int = 0, take: Int = 10): AiLibraryUpdateQueryResult!
  aiLibraryUsage(assistantId: String, libraryId: String): [AiLibraryUsage!]!
  aiList(id: String!): AiList!
  aiListEnrichments(
    fieldId: String
    fileId: String
    listId: String
    skip: Int = 0
    status: EnrichmentStatus
    take: Int = 20
  ): EnrichmentQueueResult!
  aiListEnrichmentsStatistics(listId: String!): [AiListFieldStatistics!]!
  aiListItems(
    fieldIds: [String!]!
    filters: [AiListFilterInput!]
    listId: String!
    showArchived: Boolean = false
    skip: Int! = 0
    sorting: [AiListSortingInput!]
    take: Int! = 20
  ): ListItemsQueryResult!
  aiLists: [AiList!]!
  aiModelUsageByType(endDate: DateTime, libraryId: String, startDate: DateTime, userId: String): [ModelUsageByType!]!
  aiModelUsageStats(
    assistantId: String
    endDate: DateTime
    libraryId: String
    listId: String
    modelId: String
    startDate: DateTime
    usageType: String
    userId: String
  ): ModelUsageStats
  aiServiceProvider(id: ID!): AiServiceProvider
  aiServiceProviders(enabled: Boolean): [AiServiceProvider!]!
  aiServiceStatus: AiServiceClusterStatus!
  aiSimilarFileChunks(fileId: String!, hits: Int = 20, term: String): [FileChunk!]!
  apiCrawlerTemplates: [ApiCrawlerTemplate!]!
  apiKeys(libraryId: String!): [ApiKey!]!
  checkFileExistsByOriginUri(libraryId: String!, originUriPrefix: String!): CheckFileExistsByOriginUriResult!
  managedUsers(filter: String, skip: Int! = 0, statusFilter: String, take: Int! = 100): ManagedUsersResponse!
  queryAiLibraryFiles(libraryId: String!, query: String!, skip: Int!, take: Int!): AiLibraryQueryResult!
  queueSystemStatus: QueueSystemStatus!
  user(email: String!): User
  userProfile: UserProfile!
  users: [User!]!
  version: String
  workspace(id: ID!): Workspace
  workspaces: [Workspace!]!
}

type QueueOperationResult {
  affectedCount: Int
  message: String!
  success: Boolean!
}

type QueueStatus {
  completedTasks: Int!
  failedTasks: Int!
  isRunning: Boolean!
  lastProcessedAt: String
  pendingTasks: Int!
  processingTasks: Int!
  queueType: QueueType!
}

type QueueSystemStatus {
  allWorkersRunning: Boolean!
  lastUpdated: String!
  queues: [QueueStatus!]!
  totalFailedTasks: Int!
  totalPendingTasks: Int!
  totalProcessingTasks: Int!
}

enum QueueType {
  CONTENT_PROCESSING
  ENRICHMENT
}

type RestoreDefaultProvidersResult {
  created: Int!
  providers: [AiServiceProvider!]!
  skipped: Int!
}

type SharePointValidationResult {
  errorMessage: String
  errorType: String
  success: Boolean
}

type SourceFileLink {
  fileName: String!
  url: String!
}

type SyncModelsResult {
  errors: [String!]!
  modelsDiscovered: Int!
  success: Boolean!
}

input TestProviderConnectionInput {
  apiKey: String
  baseUrl: String
  provider: String!
  providerId: String
}

type TestProviderConnectionResult {
  details: String
  message: String!
  success: Boolean!
}

input UpdateAiLanguageModelInput {
  adminNotes: String
  enabled: Boolean!
}

type UpdateLibraryParticipantsResult {
  addedParticipants: Int!
  removedParticipants: Int!
  totalParticipants: Int!
}

type UpdateListParticipantsResult {
  addedParticipants: Int!
  removedParticipants: Int!
  totalParticipants: Int!
}

type UpdateStats {
  count: Int
  updateType: String
}

type User {
  avatarUrl: String
  createdAt: DateTime!
  defaultWorkspaceId: ID!
  email: String!
  family_name: String
  given_name: String
  id: ID!
  isAdmin: Boolean!
  lastLogin: DateTime
  name: String
  profile: UserProfile
  registered: Boolean
  updatedAt: DateTime
  username: String!
}

input UserInput {
  avatarUrl: String
  email: String!
  family_name: String
  given_name: String
  name: String!
}

type UserProfile {
  activationDate: DateTime
  business: String
  confirmationDate: DateTime
  createdAt: DateTime!
  email: String!
  expiresAt: DateTime
  firstName: String
  freeMessages: Int!
  freeStorage: Int!
  id: ID!
  lastName: String
  position: String
  updatedAt: DateTime
  usedMessages: Int
  usedStorage: BigInt
  userId: ID!
}

input UserProfileInput {
  business: String
  email: String!
  firstName: String
  freeMessages: Int
  freeStorage: Int
  lastName: String
  position: String
}

type UserStatistic {
  activated: Int!
  confirmed: Int!
  total: Int!
  unactivated: Int!
  unconfirmed: Int!
}

type Workspace {
  assistants: [AiAssistant!]!
  createdAt: DateTime!
  id: ID!
  isDefault: Boolean!
  libraries: [AiLibrary!]!
  lists: [AiList!]!
  members: [WorkspaceMember!]!
  name: String!
  slug: String!
  updatedAt: DateTime!
}

type WorkspaceDeletionValidation {
  assistantCount: Int!
  canDelete: Boolean!
  libraryCount: Int!
  listCount: Int!
  message: String!
}

type WorkspaceMember {
  createdAt: DateTime!
  id: ID!
  role: String!
  user: User!
  workspace: Workspace!
}
