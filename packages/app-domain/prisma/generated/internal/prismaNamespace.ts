
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.2.0
 * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
 */
export const prismaVersion: PrismaVersion = {
  client: "7.2.0",
  engine: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  User: 'User',
  UserProfile: 'UserProfile',
  Workspace: 'Workspace',
  WorkspaceMember: 'WorkspaceMember',
  WorkspaceInvitation: 'WorkspaceInvitation',
  AiServiceProvider: 'AiServiceProvider',
  AiAssistant: 'AiAssistant',
  AiAssistantBaseCase: 'AiAssistantBaseCase',
  AiAssistantEUActAnswers: 'AiAssistantEUActAnswers',
  AiLibrary: 'AiLibrary',
  AiLibraryUsage: 'AiLibraryUsage',
  AiLibraryFile: 'AiLibraryFile',
  AiContentProcessingTask: 'AiContentProcessingTask',
  AiContentExtractionSubTask: 'AiContentExtractionSubTask',
  AiLibraryCrawler: 'AiLibraryCrawler',
  AiLibraryCrawlerRun: 'AiLibraryCrawlerRun',
  AiLibraryCrawlerCronJob: 'AiLibraryCrawlerCronJob',
  AiLibraryUpdate: 'AiLibraryUpdate',
  AiList: 'AiList',
  AiListSource: 'AiListSource',
  AiListItem: 'AiListItem',
  AiListField: 'AiListField',
  AiListFieldContext: 'AiListFieldContext',
  AiListItemCache: 'AiListItemCache',
  AiEnrichmentTask: 'AiEnrichmentTask',
  AiConversation: 'AiConversation',
  AiConversationParticipant: 'AiConversationParticipant',
  AiConversationMessage: 'AiConversationMessage',
  AiConversationInvitation: 'AiConversationInvitation',
  ApiKey: 'ApiKey',
  AiLanguageModel: 'AiLanguageModel',
  AiModelUsage: 'AiModelUsage',
  AiConnectorTypeWorkspace: 'AiConnectorTypeWorkspace',
  AiConnector: 'AiConnector',
  AiAutomation: 'AiAutomation',
  AiAutomationItem: 'AiAutomationItem',
  AiAutomationItemExecution: 'AiAutomationItemExecution',
  AiAutomationBatch: 'AiAutomationBatch'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "user" | "userProfile" | "workspace" | "workspaceMember" | "workspaceInvitation" | "aiServiceProvider" | "aiAssistant" | "aiAssistantBaseCase" | "aiAssistantEUActAnswers" | "aiLibrary" | "aiLibraryUsage" | "aiLibraryFile" | "aiContentProcessingTask" | "aiContentExtractionSubTask" | "aiLibraryCrawler" | "aiLibraryCrawlerRun" | "aiLibraryCrawlerCronJob" | "aiLibraryUpdate" | "aiList" | "aiListSource" | "aiListItem" | "aiListField" | "aiListFieldContext" | "aiListItemCache" | "aiEnrichmentTask" | "aiConversation" | "aiConversationParticipant" | "aiConversationMessage" | "aiConversationInvitation" | "apiKey" | "aiLanguageModel" | "aiModelUsage" | "aiConnectorTypeWorkspace" | "aiConnector" | "aiAutomation" | "aiAutomationItem" | "aiAutomationItemExecution" | "aiAutomationBatch"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    UserProfile: {
      payload: Prisma.$UserProfilePayload<ExtArgs>
      fields: Prisma.UserProfileFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        findFirst: {
          args: Prisma.UserProfileFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        findMany: {
          args: Prisma.UserProfileFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
        }
        create: {
          args: Prisma.UserProfileCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        createMany: {
          args: Prisma.UserProfileCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
        }
        delete: {
          args: Prisma.UserProfileDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        update: {
          args: Prisma.UserProfileUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        deleteMany: {
          args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
        }
        upsert: {
          args: Prisma.UserProfileUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        aggregate: {
          args: Prisma.UserProfileAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserProfile>
        }
        groupBy: {
          args: Prisma.UserProfileGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserProfileGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserProfileCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserProfileCountAggregateOutputType> | number
        }
      }
    }
    Workspace: {
      payload: Prisma.$WorkspacePayload<ExtArgs>
      fields: Prisma.WorkspaceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WorkspaceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WorkspaceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspacePayload>
        }
        findFirst: {
          args: Prisma.WorkspaceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WorkspaceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspacePayload>
        }
        findMany: {
          args: Prisma.WorkspaceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
        }
        create: {
          args: Prisma.WorkspaceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspacePayload>
        }
        createMany: {
          args: Prisma.WorkspaceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WorkspaceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
        }
        delete: {
          args: Prisma.WorkspaceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspacePayload>
        }
        update: {
          args: Prisma.WorkspaceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspacePayload>
        }
        deleteMany: {
          args: Prisma.WorkspaceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WorkspaceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WorkspaceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
        }
        upsert: {
          args: Prisma.WorkspaceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspacePayload>
        }
        aggregate: {
          args: Prisma.WorkspaceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWorkspace>
        }
        groupBy: {
          args: Prisma.WorkspaceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkspaceGroupByOutputType>[]
        }
        count: {
          args: Prisma.WorkspaceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkspaceCountAggregateOutputType> | number
        }
      }
    }
    WorkspaceMember: {
      payload: Prisma.$WorkspaceMemberPayload<ExtArgs>
      fields: Prisma.WorkspaceMemberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WorkspaceMemberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WorkspaceMemberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
        }
        findFirst: {
          args: Prisma.WorkspaceMemberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WorkspaceMemberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
        }
        findMany: {
          args: Prisma.WorkspaceMemberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>[]
        }
        create: {
          args: Prisma.WorkspaceMemberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
        }
        createMany: {
          args: Prisma.WorkspaceMemberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WorkspaceMemberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>[]
        }
        delete: {
          args: Prisma.WorkspaceMemberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
        }
        update: {
          args: Prisma.WorkspaceMemberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
        }
        deleteMany: {
          args: Prisma.WorkspaceMemberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WorkspaceMemberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WorkspaceMemberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>[]
        }
        upsert: {
          args: Prisma.WorkspaceMemberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
        }
        aggregate: {
          args: Prisma.WorkspaceMemberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWorkspaceMember>
        }
        groupBy: {
          args: Prisma.WorkspaceMemberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkspaceMemberGroupByOutputType>[]
        }
        count: {
          args: Prisma.WorkspaceMemberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkspaceMemberCountAggregateOutputType> | number
        }
      }
    }
    WorkspaceInvitation: {
      payload: Prisma.$WorkspaceInvitationPayload<ExtArgs>
      fields: Prisma.WorkspaceInvitationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WorkspaceInvitationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WorkspaceInvitationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
        }
        findFirst: {
          args: Prisma.WorkspaceInvitationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WorkspaceInvitationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
        }
        findMany: {
          args: Prisma.WorkspaceInvitationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>[]
        }
        create: {
          args: Prisma.WorkspaceInvitationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
        }
        createMany: {
          args: Prisma.WorkspaceInvitationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WorkspaceInvitationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>[]
        }
        delete: {
          args: Prisma.WorkspaceInvitationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
        }
        update: {
          args: Prisma.WorkspaceInvitationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
        }
        deleteMany: {
          args: Prisma.WorkspaceInvitationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WorkspaceInvitationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WorkspaceInvitationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>[]
        }
        upsert: {
          args: Prisma.WorkspaceInvitationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkspaceInvitationPayload>
        }
        aggregate: {
          args: Prisma.WorkspaceInvitationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWorkspaceInvitation>
        }
        groupBy: {
          args: Prisma.WorkspaceInvitationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkspaceInvitationGroupByOutputType>[]
        }
        count: {
          args: Prisma.WorkspaceInvitationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkspaceInvitationCountAggregateOutputType> | number
        }
      }
    }
    AiServiceProvider: {
      payload: Prisma.$AiServiceProviderPayload<ExtArgs>
      fields: Prisma.AiServiceProviderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiServiceProviderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiServiceProviderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiServiceProviderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiServiceProviderPayload>
        }
        findFirst: {
          args: Prisma.AiServiceProviderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiServiceProviderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiServiceProviderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiServiceProviderPayload>
        }
        findMany: {
          args: Prisma.AiServiceProviderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiServiceProviderPayload>[]
        }
        create: {
          args: Prisma.AiServiceProviderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiServiceProviderPayload>
        }
        createMany: {
          args: Prisma.AiServiceProviderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiServiceProviderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiServiceProviderPayload>[]
        }
        delete: {
          args: Prisma.AiServiceProviderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiServiceProviderPayload>
        }
        update: {
          args: Prisma.AiServiceProviderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiServiceProviderPayload>
        }
        deleteMany: {
          args: Prisma.AiServiceProviderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiServiceProviderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiServiceProviderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiServiceProviderPayload>[]
        }
        upsert: {
          args: Prisma.AiServiceProviderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiServiceProviderPayload>
        }
        aggregate: {
          args: Prisma.AiServiceProviderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiServiceProvider>
        }
        groupBy: {
          args: Prisma.AiServiceProviderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiServiceProviderGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiServiceProviderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiServiceProviderCountAggregateOutputType> | number
        }
      }
    }
    AiAssistant: {
      payload: Prisma.$AiAssistantPayload<ExtArgs>
      fields: Prisma.AiAssistantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiAssistantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiAssistantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantPayload>
        }
        findFirst: {
          args: Prisma.AiAssistantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiAssistantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantPayload>
        }
        findMany: {
          args: Prisma.AiAssistantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantPayload>[]
        }
        create: {
          args: Prisma.AiAssistantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantPayload>
        }
        createMany: {
          args: Prisma.AiAssistantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiAssistantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantPayload>[]
        }
        delete: {
          args: Prisma.AiAssistantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantPayload>
        }
        update: {
          args: Prisma.AiAssistantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantPayload>
        }
        deleteMany: {
          args: Prisma.AiAssistantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiAssistantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiAssistantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantPayload>[]
        }
        upsert: {
          args: Prisma.AiAssistantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantPayload>
        }
        aggregate: {
          args: Prisma.AiAssistantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiAssistant>
        }
        groupBy: {
          args: Prisma.AiAssistantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiAssistantGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiAssistantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiAssistantCountAggregateOutputType> | number
        }
      }
    }
    AiAssistantBaseCase: {
      payload: Prisma.$AiAssistantBaseCasePayload<ExtArgs>
      fields: Prisma.AiAssistantBaseCaseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiAssistantBaseCaseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantBaseCasePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiAssistantBaseCaseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantBaseCasePayload>
        }
        findFirst: {
          args: Prisma.AiAssistantBaseCaseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantBaseCasePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiAssistantBaseCaseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantBaseCasePayload>
        }
        findMany: {
          args: Prisma.AiAssistantBaseCaseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantBaseCasePayload>[]
        }
        create: {
          args: Prisma.AiAssistantBaseCaseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantBaseCasePayload>
        }
        createMany: {
          args: Prisma.AiAssistantBaseCaseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiAssistantBaseCaseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantBaseCasePayload>[]
        }
        delete: {
          args: Prisma.AiAssistantBaseCaseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantBaseCasePayload>
        }
        update: {
          args: Prisma.AiAssistantBaseCaseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantBaseCasePayload>
        }
        deleteMany: {
          args: Prisma.AiAssistantBaseCaseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiAssistantBaseCaseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiAssistantBaseCaseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantBaseCasePayload>[]
        }
        upsert: {
          args: Prisma.AiAssistantBaseCaseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantBaseCasePayload>
        }
        aggregate: {
          args: Prisma.AiAssistantBaseCaseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiAssistantBaseCase>
        }
        groupBy: {
          args: Prisma.AiAssistantBaseCaseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiAssistantBaseCaseGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiAssistantBaseCaseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiAssistantBaseCaseCountAggregateOutputType> | number
        }
      }
    }
    AiAssistantEUActAnswers: {
      payload: Prisma.$AiAssistantEUActAnswersPayload<ExtArgs>
      fields: Prisma.AiAssistantEUActAnswersFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiAssistantEUActAnswersFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantEUActAnswersPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiAssistantEUActAnswersFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantEUActAnswersPayload>
        }
        findFirst: {
          args: Prisma.AiAssistantEUActAnswersFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantEUActAnswersPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiAssistantEUActAnswersFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantEUActAnswersPayload>
        }
        findMany: {
          args: Prisma.AiAssistantEUActAnswersFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantEUActAnswersPayload>[]
        }
        create: {
          args: Prisma.AiAssistantEUActAnswersCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantEUActAnswersPayload>
        }
        createMany: {
          args: Prisma.AiAssistantEUActAnswersCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiAssistantEUActAnswersCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantEUActAnswersPayload>[]
        }
        delete: {
          args: Prisma.AiAssistantEUActAnswersDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantEUActAnswersPayload>
        }
        update: {
          args: Prisma.AiAssistantEUActAnswersUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantEUActAnswersPayload>
        }
        deleteMany: {
          args: Prisma.AiAssistantEUActAnswersDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiAssistantEUActAnswersUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiAssistantEUActAnswersUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantEUActAnswersPayload>[]
        }
        upsert: {
          args: Prisma.AiAssistantEUActAnswersUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAssistantEUActAnswersPayload>
        }
        aggregate: {
          args: Prisma.AiAssistantEUActAnswersAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiAssistantEUActAnswers>
        }
        groupBy: {
          args: Prisma.AiAssistantEUActAnswersGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiAssistantEUActAnswersGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiAssistantEUActAnswersCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiAssistantEUActAnswersCountAggregateOutputType> | number
        }
      }
    }
    AiLibrary: {
      payload: Prisma.$AiLibraryPayload<ExtArgs>
      fields: Prisma.AiLibraryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiLibraryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiLibraryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryPayload>
        }
        findFirst: {
          args: Prisma.AiLibraryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiLibraryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryPayload>
        }
        findMany: {
          args: Prisma.AiLibraryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryPayload>[]
        }
        create: {
          args: Prisma.AiLibraryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryPayload>
        }
        createMany: {
          args: Prisma.AiLibraryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiLibraryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryPayload>[]
        }
        delete: {
          args: Prisma.AiLibraryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryPayload>
        }
        update: {
          args: Prisma.AiLibraryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryPayload>
        }
        deleteMany: {
          args: Prisma.AiLibraryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiLibraryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiLibraryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryPayload>[]
        }
        upsert: {
          args: Prisma.AiLibraryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryPayload>
        }
        aggregate: {
          args: Prisma.AiLibraryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiLibrary>
        }
        groupBy: {
          args: Prisma.AiLibraryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiLibraryGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiLibraryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiLibraryCountAggregateOutputType> | number
        }
      }
    }
    AiLibraryUsage: {
      payload: Prisma.$AiLibraryUsagePayload<ExtArgs>
      fields: Prisma.AiLibraryUsageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiLibraryUsageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUsagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiLibraryUsageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUsagePayload>
        }
        findFirst: {
          args: Prisma.AiLibraryUsageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUsagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiLibraryUsageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUsagePayload>
        }
        findMany: {
          args: Prisma.AiLibraryUsageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUsagePayload>[]
        }
        create: {
          args: Prisma.AiLibraryUsageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUsagePayload>
        }
        createMany: {
          args: Prisma.AiLibraryUsageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiLibraryUsageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUsagePayload>[]
        }
        delete: {
          args: Prisma.AiLibraryUsageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUsagePayload>
        }
        update: {
          args: Prisma.AiLibraryUsageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUsagePayload>
        }
        deleteMany: {
          args: Prisma.AiLibraryUsageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiLibraryUsageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiLibraryUsageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUsagePayload>[]
        }
        upsert: {
          args: Prisma.AiLibraryUsageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUsagePayload>
        }
        aggregate: {
          args: Prisma.AiLibraryUsageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiLibraryUsage>
        }
        groupBy: {
          args: Prisma.AiLibraryUsageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiLibraryUsageGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiLibraryUsageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiLibraryUsageCountAggregateOutputType> | number
        }
      }
    }
    AiLibraryFile: {
      payload: Prisma.$AiLibraryFilePayload<ExtArgs>
      fields: Prisma.AiLibraryFileFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiLibraryFileFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryFilePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiLibraryFileFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryFilePayload>
        }
        findFirst: {
          args: Prisma.AiLibraryFileFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryFilePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiLibraryFileFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryFilePayload>
        }
        findMany: {
          args: Prisma.AiLibraryFileFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryFilePayload>[]
        }
        create: {
          args: Prisma.AiLibraryFileCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryFilePayload>
        }
        createMany: {
          args: Prisma.AiLibraryFileCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiLibraryFileCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryFilePayload>[]
        }
        delete: {
          args: Prisma.AiLibraryFileDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryFilePayload>
        }
        update: {
          args: Prisma.AiLibraryFileUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryFilePayload>
        }
        deleteMany: {
          args: Prisma.AiLibraryFileDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiLibraryFileUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiLibraryFileUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryFilePayload>[]
        }
        upsert: {
          args: Prisma.AiLibraryFileUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryFilePayload>
        }
        aggregate: {
          args: Prisma.AiLibraryFileAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiLibraryFile>
        }
        groupBy: {
          args: Prisma.AiLibraryFileGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiLibraryFileGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiLibraryFileCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiLibraryFileCountAggregateOutputType> | number
        }
      }
    }
    AiContentProcessingTask: {
      payload: Prisma.$AiContentProcessingTaskPayload<ExtArgs>
      fields: Prisma.AiContentProcessingTaskFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiContentProcessingTaskFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentProcessingTaskPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiContentProcessingTaskFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentProcessingTaskPayload>
        }
        findFirst: {
          args: Prisma.AiContentProcessingTaskFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentProcessingTaskPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiContentProcessingTaskFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentProcessingTaskPayload>
        }
        findMany: {
          args: Prisma.AiContentProcessingTaskFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentProcessingTaskPayload>[]
        }
        create: {
          args: Prisma.AiContentProcessingTaskCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentProcessingTaskPayload>
        }
        createMany: {
          args: Prisma.AiContentProcessingTaskCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiContentProcessingTaskCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentProcessingTaskPayload>[]
        }
        delete: {
          args: Prisma.AiContentProcessingTaskDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentProcessingTaskPayload>
        }
        update: {
          args: Prisma.AiContentProcessingTaskUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentProcessingTaskPayload>
        }
        deleteMany: {
          args: Prisma.AiContentProcessingTaskDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiContentProcessingTaskUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiContentProcessingTaskUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentProcessingTaskPayload>[]
        }
        upsert: {
          args: Prisma.AiContentProcessingTaskUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentProcessingTaskPayload>
        }
        aggregate: {
          args: Prisma.AiContentProcessingTaskAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiContentProcessingTask>
        }
        groupBy: {
          args: Prisma.AiContentProcessingTaskGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiContentProcessingTaskGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiContentProcessingTaskCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiContentProcessingTaskCountAggregateOutputType> | number
        }
      }
    }
    AiContentExtractionSubTask: {
      payload: Prisma.$AiContentExtractionSubTaskPayload<ExtArgs>
      fields: Prisma.AiContentExtractionSubTaskFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiContentExtractionSubTaskFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentExtractionSubTaskPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiContentExtractionSubTaskFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentExtractionSubTaskPayload>
        }
        findFirst: {
          args: Prisma.AiContentExtractionSubTaskFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentExtractionSubTaskPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiContentExtractionSubTaskFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentExtractionSubTaskPayload>
        }
        findMany: {
          args: Prisma.AiContentExtractionSubTaskFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentExtractionSubTaskPayload>[]
        }
        create: {
          args: Prisma.AiContentExtractionSubTaskCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentExtractionSubTaskPayload>
        }
        createMany: {
          args: Prisma.AiContentExtractionSubTaskCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiContentExtractionSubTaskCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentExtractionSubTaskPayload>[]
        }
        delete: {
          args: Prisma.AiContentExtractionSubTaskDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentExtractionSubTaskPayload>
        }
        update: {
          args: Prisma.AiContentExtractionSubTaskUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentExtractionSubTaskPayload>
        }
        deleteMany: {
          args: Prisma.AiContentExtractionSubTaskDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiContentExtractionSubTaskUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiContentExtractionSubTaskUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentExtractionSubTaskPayload>[]
        }
        upsert: {
          args: Prisma.AiContentExtractionSubTaskUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiContentExtractionSubTaskPayload>
        }
        aggregate: {
          args: Prisma.AiContentExtractionSubTaskAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiContentExtractionSubTask>
        }
        groupBy: {
          args: Prisma.AiContentExtractionSubTaskGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiContentExtractionSubTaskGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiContentExtractionSubTaskCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiContentExtractionSubTaskCountAggregateOutputType> | number
        }
      }
    }
    AiLibraryCrawler: {
      payload: Prisma.$AiLibraryCrawlerPayload<ExtArgs>
      fields: Prisma.AiLibraryCrawlerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiLibraryCrawlerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiLibraryCrawlerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerPayload>
        }
        findFirst: {
          args: Prisma.AiLibraryCrawlerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiLibraryCrawlerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerPayload>
        }
        findMany: {
          args: Prisma.AiLibraryCrawlerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerPayload>[]
        }
        create: {
          args: Prisma.AiLibraryCrawlerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerPayload>
        }
        createMany: {
          args: Prisma.AiLibraryCrawlerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiLibraryCrawlerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerPayload>[]
        }
        delete: {
          args: Prisma.AiLibraryCrawlerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerPayload>
        }
        update: {
          args: Prisma.AiLibraryCrawlerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerPayload>
        }
        deleteMany: {
          args: Prisma.AiLibraryCrawlerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiLibraryCrawlerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiLibraryCrawlerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerPayload>[]
        }
        upsert: {
          args: Prisma.AiLibraryCrawlerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerPayload>
        }
        aggregate: {
          args: Prisma.AiLibraryCrawlerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiLibraryCrawler>
        }
        groupBy: {
          args: Prisma.AiLibraryCrawlerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiLibraryCrawlerGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiLibraryCrawlerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiLibraryCrawlerCountAggregateOutputType> | number
        }
      }
    }
    AiLibraryCrawlerRun: {
      payload: Prisma.$AiLibraryCrawlerRunPayload<ExtArgs>
      fields: Prisma.AiLibraryCrawlerRunFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiLibraryCrawlerRunFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerRunPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiLibraryCrawlerRunFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerRunPayload>
        }
        findFirst: {
          args: Prisma.AiLibraryCrawlerRunFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerRunPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiLibraryCrawlerRunFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerRunPayload>
        }
        findMany: {
          args: Prisma.AiLibraryCrawlerRunFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerRunPayload>[]
        }
        create: {
          args: Prisma.AiLibraryCrawlerRunCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerRunPayload>
        }
        createMany: {
          args: Prisma.AiLibraryCrawlerRunCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiLibraryCrawlerRunCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerRunPayload>[]
        }
        delete: {
          args: Prisma.AiLibraryCrawlerRunDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerRunPayload>
        }
        update: {
          args: Prisma.AiLibraryCrawlerRunUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerRunPayload>
        }
        deleteMany: {
          args: Prisma.AiLibraryCrawlerRunDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiLibraryCrawlerRunUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiLibraryCrawlerRunUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerRunPayload>[]
        }
        upsert: {
          args: Prisma.AiLibraryCrawlerRunUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerRunPayload>
        }
        aggregate: {
          args: Prisma.AiLibraryCrawlerRunAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiLibraryCrawlerRun>
        }
        groupBy: {
          args: Prisma.AiLibraryCrawlerRunGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiLibraryCrawlerRunGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiLibraryCrawlerRunCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiLibraryCrawlerRunCountAggregateOutputType> | number
        }
      }
    }
    AiLibraryCrawlerCronJob: {
      payload: Prisma.$AiLibraryCrawlerCronJobPayload<ExtArgs>
      fields: Prisma.AiLibraryCrawlerCronJobFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiLibraryCrawlerCronJobFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerCronJobPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiLibraryCrawlerCronJobFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerCronJobPayload>
        }
        findFirst: {
          args: Prisma.AiLibraryCrawlerCronJobFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerCronJobPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiLibraryCrawlerCronJobFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerCronJobPayload>
        }
        findMany: {
          args: Prisma.AiLibraryCrawlerCronJobFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerCronJobPayload>[]
        }
        create: {
          args: Prisma.AiLibraryCrawlerCronJobCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerCronJobPayload>
        }
        createMany: {
          args: Prisma.AiLibraryCrawlerCronJobCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiLibraryCrawlerCronJobCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerCronJobPayload>[]
        }
        delete: {
          args: Prisma.AiLibraryCrawlerCronJobDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerCronJobPayload>
        }
        update: {
          args: Prisma.AiLibraryCrawlerCronJobUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerCronJobPayload>
        }
        deleteMany: {
          args: Prisma.AiLibraryCrawlerCronJobDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiLibraryCrawlerCronJobUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiLibraryCrawlerCronJobUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerCronJobPayload>[]
        }
        upsert: {
          args: Prisma.AiLibraryCrawlerCronJobUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryCrawlerCronJobPayload>
        }
        aggregate: {
          args: Prisma.AiLibraryCrawlerCronJobAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiLibraryCrawlerCronJob>
        }
        groupBy: {
          args: Prisma.AiLibraryCrawlerCronJobGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiLibraryCrawlerCronJobGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiLibraryCrawlerCronJobCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiLibraryCrawlerCronJobCountAggregateOutputType> | number
        }
      }
    }
    AiLibraryUpdate: {
      payload: Prisma.$AiLibraryUpdatePayload<ExtArgs>
      fields: Prisma.AiLibraryUpdateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiLibraryUpdateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUpdatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiLibraryUpdateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUpdatePayload>
        }
        findFirst: {
          args: Prisma.AiLibraryUpdateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUpdatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiLibraryUpdateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUpdatePayload>
        }
        findMany: {
          args: Prisma.AiLibraryUpdateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUpdatePayload>[]
        }
        create: {
          args: Prisma.AiLibraryUpdateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUpdatePayload>
        }
        createMany: {
          args: Prisma.AiLibraryUpdateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiLibraryUpdateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUpdatePayload>[]
        }
        delete: {
          args: Prisma.AiLibraryUpdateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUpdatePayload>
        }
        update: {
          args: Prisma.AiLibraryUpdateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUpdatePayload>
        }
        deleteMany: {
          args: Prisma.AiLibraryUpdateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiLibraryUpdateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiLibraryUpdateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUpdatePayload>[]
        }
        upsert: {
          args: Prisma.AiLibraryUpdateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLibraryUpdatePayload>
        }
        aggregate: {
          args: Prisma.AiLibraryUpdateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiLibraryUpdate>
        }
        groupBy: {
          args: Prisma.AiLibraryUpdateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiLibraryUpdateGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiLibraryUpdateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiLibraryUpdateCountAggregateOutputType> | number
        }
      }
    }
    AiList: {
      payload: Prisma.$AiListPayload<ExtArgs>
      fields: Prisma.AiListFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiListFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiListFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListPayload>
        }
        findFirst: {
          args: Prisma.AiListFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiListFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListPayload>
        }
        findMany: {
          args: Prisma.AiListFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListPayload>[]
        }
        create: {
          args: Prisma.AiListCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListPayload>
        }
        createMany: {
          args: Prisma.AiListCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiListCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListPayload>[]
        }
        delete: {
          args: Prisma.AiListDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListPayload>
        }
        update: {
          args: Prisma.AiListUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListPayload>
        }
        deleteMany: {
          args: Prisma.AiListDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiListUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiListUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListPayload>[]
        }
        upsert: {
          args: Prisma.AiListUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListPayload>
        }
        aggregate: {
          args: Prisma.AiListAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiList>
        }
        groupBy: {
          args: Prisma.AiListGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiListGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiListCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiListCountAggregateOutputType> | number
        }
      }
    }
    AiListSource: {
      payload: Prisma.$AiListSourcePayload<ExtArgs>
      fields: Prisma.AiListSourceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiListSourceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListSourcePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiListSourceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListSourcePayload>
        }
        findFirst: {
          args: Prisma.AiListSourceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListSourcePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiListSourceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListSourcePayload>
        }
        findMany: {
          args: Prisma.AiListSourceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListSourcePayload>[]
        }
        create: {
          args: Prisma.AiListSourceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListSourcePayload>
        }
        createMany: {
          args: Prisma.AiListSourceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiListSourceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListSourcePayload>[]
        }
        delete: {
          args: Prisma.AiListSourceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListSourcePayload>
        }
        update: {
          args: Prisma.AiListSourceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListSourcePayload>
        }
        deleteMany: {
          args: Prisma.AiListSourceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiListSourceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiListSourceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListSourcePayload>[]
        }
        upsert: {
          args: Prisma.AiListSourceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListSourcePayload>
        }
        aggregate: {
          args: Prisma.AiListSourceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiListSource>
        }
        groupBy: {
          args: Prisma.AiListSourceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiListSourceGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiListSourceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiListSourceCountAggregateOutputType> | number
        }
      }
    }
    AiListItem: {
      payload: Prisma.$AiListItemPayload<ExtArgs>
      fields: Prisma.AiListItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiListItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiListItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemPayload>
        }
        findFirst: {
          args: Prisma.AiListItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiListItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemPayload>
        }
        findMany: {
          args: Prisma.AiListItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemPayload>[]
        }
        create: {
          args: Prisma.AiListItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemPayload>
        }
        createMany: {
          args: Prisma.AiListItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiListItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemPayload>[]
        }
        delete: {
          args: Prisma.AiListItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemPayload>
        }
        update: {
          args: Prisma.AiListItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemPayload>
        }
        deleteMany: {
          args: Prisma.AiListItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiListItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiListItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemPayload>[]
        }
        upsert: {
          args: Prisma.AiListItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemPayload>
        }
        aggregate: {
          args: Prisma.AiListItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiListItem>
        }
        groupBy: {
          args: Prisma.AiListItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiListItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiListItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiListItemCountAggregateOutputType> | number
        }
      }
    }
    AiListField: {
      payload: Prisma.$AiListFieldPayload<ExtArgs>
      fields: Prisma.AiListFieldFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiListFieldFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiListFieldFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldPayload>
        }
        findFirst: {
          args: Prisma.AiListFieldFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiListFieldFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldPayload>
        }
        findMany: {
          args: Prisma.AiListFieldFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldPayload>[]
        }
        create: {
          args: Prisma.AiListFieldCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldPayload>
        }
        createMany: {
          args: Prisma.AiListFieldCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiListFieldCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldPayload>[]
        }
        delete: {
          args: Prisma.AiListFieldDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldPayload>
        }
        update: {
          args: Prisma.AiListFieldUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldPayload>
        }
        deleteMany: {
          args: Prisma.AiListFieldDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiListFieldUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiListFieldUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldPayload>[]
        }
        upsert: {
          args: Prisma.AiListFieldUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldPayload>
        }
        aggregate: {
          args: Prisma.AiListFieldAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiListField>
        }
        groupBy: {
          args: Prisma.AiListFieldGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiListFieldGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiListFieldCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiListFieldCountAggregateOutputType> | number
        }
      }
    }
    AiListFieldContext: {
      payload: Prisma.$AiListFieldContextPayload<ExtArgs>
      fields: Prisma.AiListFieldContextFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiListFieldContextFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldContextPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiListFieldContextFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldContextPayload>
        }
        findFirst: {
          args: Prisma.AiListFieldContextFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldContextPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiListFieldContextFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldContextPayload>
        }
        findMany: {
          args: Prisma.AiListFieldContextFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldContextPayload>[]
        }
        create: {
          args: Prisma.AiListFieldContextCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldContextPayload>
        }
        createMany: {
          args: Prisma.AiListFieldContextCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiListFieldContextCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldContextPayload>[]
        }
        delete: {
          args: Prisma.AiListFieldContextDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldContextPayload>
        }
        update: {
          args: Prisma.AiListFieldContextUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldContextPayload>
        }
        deleteMany: {
          args: Prisma.AiListFieldContextDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiListFieldContextUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiListFieldContextUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldContextPayload>[]
        }
        upsert: {
          args: Prisma.AiListFieldContextUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListFieldContextPayload>
        }
        aggregate: {
          args: Prisma.AiListFieldContextAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiListFieldContext>
        }
        groupBy: {
          args: Prisma.AiListFieldContextGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiListFieldContextGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiListFieldContextCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiListFieldContextCountAggregateOutputType> | number
        }
      }
    }
    AiListItemCache: {
      payload: Prisma.$AiListItemCachePayload<ExtArgs>
      fields: Prisma.AiListItemCacheFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiListItemCacheFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemCachePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiListItemCacheFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemCachePayload>
        }
        findFirst: {
          args: Prisma.AiListItemCacheFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemCachePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiListItemCacheFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemCachePayload>
        }
        findMany: {
          args: Prisma.AiListItemCacheFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemCachePayload>[]
        }
        create: {
          args: Prisma.AiListItemCacheCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemCachePayload>
        }
        createMany: {
          args: Prisma.AiListItemCacheCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiListItemCacheCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemCachePayload>[]
        }
        delete: {
          args: Prisma.AiListItemCacheDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemCachePayload>
        }
        update: {
          args: Prisma.AiListItemCacheUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemCachePayload>
        }
        deleteMany: {
          args: Prisma.AiListItemCacheDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiListItemCacheUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiListItemCacheUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemCachePayload>[]
        }
        upsert: {
          args: Prisma.AiListItemCacheUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiListItemCachePayload>
        }
        aggregate: {
          args: Prisma.AiListItemCacheAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiListItemCache>
        }
        groupBy: {
          args: Prisma.AiListItemCacheGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiListItemCacheGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiListItemCacheCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiListItemCacheCountAggregateOutputType> | number
        }
      }
    }
    AiEnrichmentTask: {
      payload: Prisma.$AiEnrichmentTaskPayload<ExtArgs>
      fields: Prisma.AiEnrichmentTaskFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiEnrichmentTaskFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiEnrichmentTaskPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiEnrichmentTaskFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiEnrichmentTaskPayload>
        }
        findFirst: {
          args: Prisma.AiEnrichmentTaskFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiEnrichmentTaskPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiEnrichmentTaskFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiEnrichmentTaskPayload>
        }
        findMany: {
          args: Prisma.AiEnrichmentTaskFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiEnrichmentTaskPayload>[]
        }
        create: {
          args: Prisma.AiEnrichmentTaskCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiEnrichmentTaskPayload>
        }
        createMany: {
          args: Prisma.AiEnrichmentTaskCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiEnrichmentTaskCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiEnrichmentTaskPayload>[]
        }
        delete: {
          args: Prisma.AiEnrichmentTaskDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiEnrichmentTaskPayload>
        }
        update: {
          args: Prisma.AiEnrichmentTaskUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiEnrichmentTaskPayload>
        }
        deleteMany: {
          args: Prisma.AiEnrichmentTaskDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiEnrichmentTaskUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiEnrichmentTaskUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiEnrichmentTaskPayload>[]
        }
        upsert: {
          args: Prisma.AiEnrichmentTaskUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiEnrichmentTaskPayload>
        }
        aggregate: {
          args: Prisma.AiEnrichmentTaskAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiEnrichmentTask>
        }
        groupBy: {
          args: Prisma.AiEnrichmentTaskGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiEnrichmentTaskGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiEnrichmentTaskCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiEnrichmentTaskCountAggregateOutputType> | number
        }
      }
    }
    AiConversation: {
      payload: Prisma.$AiConversationPayload<ExtArgs>
      fields: Prisma.AiConversationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiConversationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiConversationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>
        }
        findFirst: {
          args: Prisma.AiConversationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiConversationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>
        }
        findMany: {
          args: Prisma.AiConversationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>[]
        }
        create: {
          args: Prisma.AiConversationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>
        }
        createMany: {
          args: Prisma.AiConversationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiConversationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>[]
        }
        delete: {
          args: Prisma.AiConversationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>
        }
        update: {
          args: Prisma.AiConversationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>
        }
        deleteMany: {
          args: Prisma.AiConversationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiConversationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiConversationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>[]
        }
        upsert: {
          args: Prisma.AiConversationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationPayload>
        }
        aggregate: {
          args: Prisma.AiConversationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiConversation>
        }
        groupBy: {
          args: Prisma.AiConversationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiConversationGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiConversationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiConversationCountAggregateOutputType> | number
        }
      }
    }
    AiConversationParticipant: {
      payload: Prisma.$AiConversationParticipantPayload<ExtArgs>
      fields: Prisma.AiConversationParticipantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiConversationParticipantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationParticipantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiConversationParticipantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationParticipantPayload>
        }
        findFirst: {
          args: Prisma.AiConversationParticipantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationParticipantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiConversationParticipantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationParticipantPayload>
        }
        findMany: {
          args: Prisma.AiConversationParticipantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationParticipantPayload>[]
        }
        create: {
          args: Prisma.AiConversationParticipantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationParticipantPayload>
        }
        createMany: {
          args: Prisma.AiConversationParticipantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiConversationParticipantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationParticipantPayload>[]
        }
        delete: {
          args: Prisma.AiConversationParticipantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationParticipantPayload>
        }
        update: {
          args: Prisma.AiConversationParticipantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationParticipantPayload>
        }
        deleteMany: {
          args: Prisma.AiConversationParticipantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiConversationParticipantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiConversationParticipantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationParticipantPayload>[]
        }
        upsert: {
          args: Prisma.AiConversationParticipantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationParticipantPayload>
        }
        aggregate: {
          args: Prisma.AiConversationParticipantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiConversationParticipant>
        }
        groupBy: {
          args: Prisma.AiConversationParticipantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiConversationParticipantGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiConversationParticipantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiConversationParticipantCountAggregateOutputType> | number
        }
      }
    }
    AiConversationMessage: {
      payload: Prisma.$AiConversationMessagePayload<ExtArgs>
      fields: Prisma.AiConversationMessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiConversationMessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationMessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiConversationMessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationMessagePayload>
        }
        findFirst: {
          args: Prisma.AiConversationMessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationMessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiConversationMessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationMessagePayload>
        }
        findMany: {
          args: Prisma.AiConversationMessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationMessagePayload>[]
        }
        create: {
          args: Prisma.AiConversationMessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationMessagePayload>
        }
        createMany: {
          args: Prisma.AiConversationMessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiConversationMessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationMessagePayload>[]
        }
        delete: {
          args: Prisma.AiConversationMessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationMessagePayload>
        }
        update: {
          args: Prisma.AiConversationMessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationMessagePayload>
        }
        deleteMany: {
          args: Prisma.AiConversationMessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiConversationMessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiConversationMessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationMessagePayload>[]
        }
        upsert: {
          args: Prisma.AiConversationMessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationMessagePayload>
        }
        aggregate: {
          args: Prisma.AiConversationMessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiConversationMessage>
        }
        groupBy: {
          args: Prisma.AiConversationMessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiConversationMessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiConversationMessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiConversationMessageCountAggregateOutputType> | number
        }
      }
    }
    AiConversationInvitation: {
      payload: Prisma.$AiConversationInvitationPayload<ExtArgs>
      fields: Prisma.AiConversationInvitationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiConversationInvitationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationInvitationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiConversationInvitationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationInvitationPayload>
        }
        findFirst: {
          args: Prisma.AiConversationInvitationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationInvitationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiConversationInvitationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationInvitationPayload>
        }
        findMany: {
          args: Prisma.AiConversationInvitationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationInvitationPayload>[]
        }
        create: {
          args: Prisma.AiConversationInvitationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationInvitationPayload>
        }
        createMany: {
          args: Prisma.AiConversationInvitationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiConversationInvitationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationInvitationPayload>[]
        }
        delete: {
          args: Prisma.AiConversationInvitationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationInvitationPayload>
        }
        update: {
          args: Prisma.AiConversationInvitationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationInvitationPayload>
        }
        deleteMany: {
          args: Prisma.AiConversationInvitationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiConversationInvitationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiConversationInvitationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationInvitationPayload>[]
        }
        upsert: {
          args: Prisma.AiConversationInvitationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConversationInvitationPayload>
        }
        aggregate: {
          args: Prisma.AiConversationInvitationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiConversationInvitation>
        }
        groupBy: {
          args: Prisma.AiConversationInvitationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiConversationInvitationGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiConversationInvitationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiConversationInvitationCountAggregateOutputType> | number
        }
      }
    }
    ApiKey: {
      payload: Prisma.$ApiKeyPayload<ExtArgs>
      fields: Prisma.ApiKeyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        findFirst: {
          args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        findMany: {
          args: Prisma.ApiKeyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
        }
        create: {
          args: Prisma.ApiKeyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        createMany: {
          args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
        }
        delete: {
          args: Prisma.ApiKeyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        update: {
          args: Prisma.ApiKeyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        deleteMany: {
          args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ApiKeyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
        }
        upsert: {
          args: Prisma.ApiKeyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        aggregate: {
          args: Prisma.ApiKeyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApiKey>
        }
        groupBy: {
          args: Prisma.ApiKeyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApiKeyGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApiKeyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApiKeyCountAggregateOutputType> | number
        }
      }
    }
    AiLanguageModel: {
      payload: Prisma.$AiLanguageModelPayload<ExtArgs>
      fields: Prisma.AiLanguageModelFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiLanguageModelFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLanguageModelPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiLanguageModelFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLanguageModelPayload>
        }
        findFirst: {
          args: Prisma.AiLanguageModelFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLanguageModelPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiLanguageModelFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLanguageModelPayload>
        }
        findMany: {
          args: Prisma.AiLanguageModelFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLanguageModelPayload>[]
        }
        create: {
          args: Prisma.AiLanguageModelCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLanguageModelPayload>
        }
        createMany: {
          args: Prisma.AiLanguageModelCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiLanguageModelCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLanguageModelPayload>[]
        }
        delete: {
          args: Prisma.AiLanguageModelDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLanguageModelPayload>
        }
        update: {
          args: Prisma.AiLanguageModelUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLanguageModelPayload>
        }
        deleteMany: {
          args: Prisma.AiLanguageModelDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiLanguageModelUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiLanguageModelUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLanguageModelPayload>[]
        }
        upsert: {
          args: Prisma.AiLanguageModelUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiLanguageModelPayload>
        }
        aggregate: {
          args: Prisma.AiLanguageModelAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiLanguageModel>
        }
        groupBy: {
          args: Prisma.AiLanguageModelGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiLanguageModelGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiLanguageModelCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiLanguageModelCountAggregateOutputType> | number
        }
      }
    }
    AiModelUsage: {
      payload: Prisma.$AiModelUsagePayload<ExtArgs>
      fields: Prisma.AiModelUsageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiModelUsageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiModelUsagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiModelUsageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiModelUsagePayload>
        }
        findFirst: {
          args: Prisma.AiModelUsageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiModelUsagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiModelUsageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiModelUsagePayload>
        }
        findMany: {
          args: Prisma.AiModelUsageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiModelUsagePayload>[]
        }
        create: {
          args: Prisma.AiModelUsageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiModelUsagePayload>
        }
        createMany: {
          args: Prisma.AiModelUsageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiModelUsageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiModelUsagePayload>[]
        }
        delete: {
          args: Prisma.AiModelUsageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiModelUsagePayload>
        }
        update: {
          args: Prisma.AiModelUsageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiModelUsagePayload>
        }
        deleteMany: {
          args: Prisma.AiModelUsageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiModelUsageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiModelUsageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiModelUsagePayload>[]
        }
        upsert: {
          args: Prisma.AiModelUsageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiModelUsagePayload>
        }
        aggregate: {
          args: Prisma.AiModelUsageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiModelUsage>
        }
        groupBy: {
          args: Prisma.AiModelUsageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiModelUsageGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiModelUsageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiModelUsageCountAggregateOutputType> | number
        }
      }
    }
    AiConnectorTypeWorkspace: {
      payload: Prisma.$AiConnectorTypeWorkspacePayload<ExtArgs>
      fields: Prisma.AiConnectorTypeWorkspaceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiConnectorTypeWorkspaceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorTypeWorkspacePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiConnectorTypeWorkspaceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorTypeWorkspacePayload>
        }
        findFirst: {
          args: Prisma.AiConnectorTypeWorkspaceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorTypeWorkspacePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiConnectorTypeWorkspaceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorTypeWorkspacePayload>
        }
        findMany: {
          args: Prisma.AiConnectorTypeWorkspaceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorTypeWorkspacePayload>[]
        }
        create: {
          args: Prisma.AiConnectorTypeWorkspaceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorTypeWorkspacePayload>
        }
        createMany: {
          args: Prisma.AiConnectorTypeWorkspaceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiConnectorTypeWorkspaceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorTypeWorkspacePayload>[]
        }
        delete: {
          args: Prisma.AiConnectorTypeWorkspaceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorTypeWorkspacePayload>
        }
        update: {
          args: Prisma.AiConnectorTypeWorkspaceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorTypeWorkspacePayload>
        }
        deleteMany: {
          args: Prisma.AiConnectorTypeWorkspaceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiConnectorTypeWorkspaceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiConnectorTypeWorkspaceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorTypeWorkspacePayload>[]
        }
        upsert: {
          args: Prisma.AiConnectorTypeWorkspaceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorTypeWorkspacePayload>
        }
        aggregate: {
          args: Prisma.AiConnectorTypeWorkspaceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiConnectorTypeWorkspace>
        }
        groupBy: {
          args: Prisma.AiConnectorTypeWorkspaceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiConnectorTypeWorkspaceGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiConnectorTypeWorkspaceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiConnectorTypeWorkspaceCountAggregateOutputType> | number
        }
      }
    }
    AiConnector: {
      payload: Prisma.$AiConnectorPayload<ExtArgs>
      fields: Prisma.AiConnectorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiConnectorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiConnectorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorPayload>
        }
        findFirst: {
          args: Prisma.AiConnectorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiConnectorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorPayload>
        }
        findMany: {
          args: Prisma.AiConnectorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorPayload>[]
        }
        create: {
          args: Prisma.AiConnectorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorPayload>
        }
        createMany: {
          args: Prisma.AiConnectorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiConnectorCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorPayload>[]
        }
        delete: {
          args: Prisma.AiConnectorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorPayload>
        }
        update: {
          args: Prisma.AiConnectorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorPayload>
        }
        deleteMany: {
          args: Prisma.AiConnectorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiConnectorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiConnectorUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorPayload>[]
        }
        upsert: {
          args: Prisma.AiConnectorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiConnectorPayload>
        }
        aggregate: {
          args: Prisma.AiConnectorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiConnector>
        }
        groupBy: {
          args: Prisma.AiConnectorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiConnectorGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiConnectorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiConnectorCountAggregateOutputType> | number
        }
      }
    }
    AiAutomation: {
      payload: Prisma.$AiAutomationPayload<ExtArgs>
      fields: Prisma.AiAutomationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiAutomationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiAutomationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationPayload>
        }
        findFirst: {
          args: Prisma.AiAutomationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiAutomationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationPayload>
        }
        findMany: {
          args: Prisma.AiAutomationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationPayload>[]
        }
        create: {
          args: Prisma.AiAutomationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationPayload>
        }
        createMany: {
          args: Prisma.AiAutomationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiAutomationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationPayload>[]
        }
        delete: {
          args: Prisma.AiAutomationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationPayload>
        }
        update: {
          args: Prisma.AiAutomationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationPayload>
        }
        deleteMany: {
          args: Prisma.AiAutomationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiAutomationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiAutomationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationPayload>[]
        }
        upsert: {
          args: Prisma.AiAutomationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationPayload>
        }
        aggregate: {
          args: Prisma.AiAutomationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiAutomation>
        }
        groupBy: {
          args: Prisma.AiAutomationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiAutomationGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiAutomationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiAutomationCountAggregateOutputType> | number
        }
      }
    }
    AiAutomationItem: {
      payload: Prisma.$AiAutomationItemPayload<ExtArgs>
      fields: Prisma.AiAutomationItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiAutomationItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiAutomationItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemPayload>
        }
        findFirst: {
          args: Prisma.AiAutomationItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiAutomationItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemPayload>
        }
        findMany: {
          args: Prisma.AiAutomationItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemPayload>[]
        }
        create: {
          args: Prisma.AiAutomationItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemPayload>
        }
        createMany: {
          args: Prisma.AiAutomationItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiAutomationItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemPayload>[]
        }
        delete: {
          args: Prisma.AiAutomationItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemPayload>
        }
        update: {
          args: Prisma.AiAutomationItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemPayload>
        }
        deleteMany: {
          args: Prisma.AiAutomationItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiAutomationItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiAutomationItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemPayload>[]
        }
        upsert: {
          args: Prisma.AiAutomationItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemPayload>
        }
        aggregate: {
          args: Prisma.AiAutomationItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiAutomationItem>
        }
        groupBy: {
          args: Prisma.AiAutomationItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiAutomationItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiAutomationItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiAutomationItemCountAggregateOutputType> | number
        }
      }
    }
    AiAutomationItemExecution: {
      payload: Prisma.$AiAutomationItemExecutionPayload<ExtArgs>
      fields: Prisma.AiAutomationItemExecutionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiAutomationItemExecutionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemExecutionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiAutomationItemExecutionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemExecutionPayload>
        }
        findFirst: {
          args: Prisma.AiAutomationItemExecutionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemExecutionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiAutomationItemExecutionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemExecutionPayload>
        }
        findMany: {
          args: Prisma.AiAutomationItemExecutionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemExecutionPayload>[]
        }
        create: {
          args: Prisma.AiAutomationItemExecutionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemExecutionPayload>
        }
        createMany: {
          args: Prisma.AiAutomationItemExecutionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiAutomationItemExecutionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemExecutionPayload>[]
        }
        delete: {
          args: Prisma.AiAutomationItemExecutionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemExecutionPayload>
        }
        update: {
          args: Prisma.AiAutomationItemExecutionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemExecutionPayload>
        }
        deleteMany: {
          args: Prisma.AiAutomationItemExecutionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiAutomationItemExecutionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiAutomationItemExecutionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemExecutionPayload>[]
        }
        upsert: {
          args: Prisma.AiAutomationItemExecutionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationItemExecutionPayload>
        }
        aggregate: {
          args: Prisma.AiAutomationItemExecutionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiAutomationItemExecution>
        }
        groupBy: {
          args: Prisma.AiAutomationItemExecutionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiAutomationItemExecutionGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiAutomationItemExecutionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiAutomationItemExecutionCountAggregateOutputType> | number
        }
      }
    }
    AiAutomationBatch: {
      payload: Prisma.$AiAutomationBatchPayload<ExtArgs>
      fields: Prisma.AiAutomationBatchFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AiAutomationBatchFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationBatchPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AiAutomationBatchFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationBatchPayload>
        }
        findFirst: {
          args: Prisma.AiAutomationBatchFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationBatchPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AiAutomationBatchFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationBatchPayload>
        }
        findMany: {
          args: Prisma.AiAutomationBatchFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationBatchPayload>[]
        }
        create: {
          args: Prisma.AiAutomationBatchCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationBatchPayload>
        }
        createMany: {
          args: Prisma.AiAutomationBatchCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AiAutomationBatchCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationBatchPayload>[]
        }
        delete: {
          args: Prisma.AiAutomationBatchDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationBatchPayload>
        }
        update: {
          args: Prisma.AiAutomationBatchUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationBatchPayload>
        }
        deleteMany: {
          args: Prisma.AiAutomationBatchDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AiAutomationBatchUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AiAutomationBatchUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationBatchPayload>[]
        }
        upsert: {
          args: Prisma.AiAutomationBatchUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AiAutomationBatchPayload>
        }
        aggregate: {
          args: Prisma.AiAutomationBatchAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAiAutomationBatch>
        }
        groupBy: {
          args: Prisma.AiAutomationBatchGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiAutomationBatchGroupByOutputType>[]
        }
        count: {
          args: Prisma.AiAutomationBatchCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AiAutomationBatchCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRawTyped: {
        args: runtime.UnknownTypedSql,
        result: JsonObject
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const UserScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  lastLogin: 'lastLogin',
  email: 'email',
  username: 'username',
  name: 'name',
  given_name: 'given_name',
  family_name: 'family_name',
  isAdmin: 'isAdmin',
  avatarUrl: 'avatarUrl',
  defaultWorkspaceId: 'defaultWorkspaceId'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const UserProfileScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  expiresAt: 'expiresAt',
  email: 'email',
  firstName: 'firstName',
  lastName: 'lastName',
  freeMessages: 'freeMessages',
  freeStorage: 'freeStorage',
  business: 'business',
  position: 'position',
  userId: 'userId',
  confirmationDate: 'confirmationDate',
  activationDate: 'activationDate'
} as const

export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


export const WorkspaceScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  name: 'name',
  slug: 'slug'
} as const

export type WorkspaceScalarFieldEnum = (typeof WorkspaceScalarFieldEnum)[keyof typeof WorkspaceScalarFieldEnum]


export const WorkspaceMemberScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  workspaceId: 'workspaceId',
  userId: 'userId',
  role: 'role'
} as const

export type WorkspaceMemberScalarFieldEnum = (typeof WorkspaceMemberScalarFieldEnum)[keyof typeof WorkspaceMemberScalarFieldEnum]


export const WorkspaceInvitationScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  workspaceId: 'workspaceId',
  email: 'email',
  inviterId: 'inviterId',
  expiresAt: 'expiresAt',
  acceptedAt: 'acceptedAt'
} as const

export type WorkspaceInvitationScalarFieldEnum = (typeof WorkspaceInvitationScalarFieldEnum)[keyof typeof WorkspaceInvitationScalarFieldEnum]


export const AiServiceProviderScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  workspaceId: 'workspaceId',
  provider: 'provider',
  name: 'name',
  enabled: 'enabled',
  baseUrl: 'baseUrl',
  apiKey: 'apiKey',
  vramGb: 'vramGb',
  createdBy: 'createdBy',
  updatedBy: 'updatedBy'
} as const

export type AiServiceProviderScalarFieldEnum = (typeof AiServiceProviderScalarFieldEnum)[keyof typeof AiServiceProviderScalarFieldEnum]


export const AiAssistantScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  name: 'name',
  description: 'description',
  url: 'url',
  ownerId: 'ownerId',
  workspaceId: 'workspaceId',
  iconUrl: 'iconUrl',
  languageModelId: 'languageModelId'
} as const

export type AiAssistantScalarFieldEnum = (typeof AiAssistantScalarFieldEnum)[keyof typeof AiAssistantScalarFieldEnum]


export const AiAssistantBaseCaseScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sequence: 'sequence',
  assistantId: 'assistantId',
  condition: 'condition',
  instruction: 'instruction'
} as const

export type AiAssistantBaseCaseScalarFieldEnum = (typeof AiAssistantBaseCaseScalarFieldEnum)[keyof typeof AiAssistantBaseCaseScalarFieldEnum]


export const AiAssistantEUActAnswersScalarFieldEnum = {
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  assistantId: 'assistantId',
  questionId: 'questionId',
  answer: 'answer',
  notes: 'notes'
} as const

export type AiAssistantEUActAnswersScalarFieldEnum = (typeof AiAssistantEUActAnswersScalarFieldEnum)[keyof typeof AiAssistantEUActAnswersScalarFieldEnum]


export const AiLibraryScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  name: 'name',
  description: 'description',
  url: 'url',
  apiToken: 'apiToken',
  lastProcessed: 'lastProcessed',
  ownerId: 'ownerId',
  workspaceId: 'workspaceId',
  isPublic: 'isPublic',
  fileConverterOptions: 'fileConverterOptions',
  embeddingTimeoutMs: 'embeddingTimeoutMs',
  autoProcessCrawledFiles: 'autoProcessCrawledFiles',
  embeddingModelId: 'embeddingModelId',
  ocrModelId: 'ocrModelId',
  extractionModelId: 'extractionModelId'
} as const

export type AiLibraryScalarFieldEnum = (typeof AiLibraryScalarFieldEnum)[keyof typeof AiLibraryScalarFieldEnum]


export const AiLibraryUsageScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  assistantId: 'assistantId',
  libraryId: 'libraryId',
  updatedAt: 'updatedAt',
  usedFor: 'usedFor'
} as const

export type AiLibraryUsageScalarFieldEnum = (typeof AiLibraryUsageScalarFieldEnum)[keyof typeof AiLibraryUsageScalarFieldEnum]


export const AiLibraryFileScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  libraryId: 'libraryId',
  name: 'name',
  originUri: 'originUri',
  mimeType: 'mimeType',
  size: 'size',
  uploadedAt: 'uploadedAt',
  dropError: 'dropError',
  crawledByCrawlerId: 'crawledByCrawlerId',
  docPath: 'docPath',
  originFileHash: 'originFileHash',
  originModificationDate: 'originModificationDate',
  archivedAt: 'archivedAt'
} as const

export type AiLibraryFileScalarFieldEnum = (typeof AiLibraryFileScalarFieldEnum)[keyof typeof AiLibraryFileScalarFieldEnum]


export const AiContentProcessingTaskScalarFieldEnum = {
  id: 'id',
  fileId: 'fileId',
  libraryId: 'libraryId',
  createdAt: 'createdAt',
  timeoutMs: 'timeoutMs',
  embeddingModelId: 'embeddingModelId',
  extractionOptions: 'extractionOptions',
  processingStartedAt: 'processingStartedAt',
  processingFinishedAt: 'processingFinishedAt',
  processingFailedAt: 'processingFailedAt',
  processingTimeout: 'processingTimeout',
  extractionStartedAt: 'extractionStartedAt',
  extractionFinishedAt: 'extractionFinishedAt',
  extractionFailedAt: 'extractionFailedAt',
  extractionTimeout: 'extractionTimeout',
  embeddingStartedAt: 'embeddingStartedAt',
  embeddingFinishedAt: 'embeddingFinishedAt',
  embeddingFailedAt: 'embeddingFailedAt',
  embeddingTimeout: 'embeddingTimeout',
  chunksCount: 'chunksCount',
  chunksSize: 'chunksSize',
  metadata: 'metadata',
  processingCancelled: 'processingCancelled'
} as const

export type AiContentProcessingTaskScalarFieldEnum = (typeof AiContentProcessingTaskScalarFieldEnum)[keyof typeof AiContentProcessingTaskScalarFieldEnum]


export const AiContentExtractionSubTaskScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  startedAt: 'startedAt',
  finishedAt: 'finishedAt',
  failedAt: 'failedAt',
  contentProcessingTaskId: 'contentProcessingTaskId',
  extractionMethod: 'extractionMethod',
  markdownFileName: 'markdownFileName'
} as const

export type AiContentExtractionSubTaskScalarFieldEnum = (typeof AiContentExtractionSubTaskScalarFieldEnum)[keyof typeof AiContentExtractionSubTaskScalarFieldEnum]


export const AiLibraryCrawlerScalarFieldEnum = {
  id: 'id',
  uri: 'uri',
  libraryId: 'libraryId',
  lastRun: 'lastRun',
  maxDepth: 'maxDepth',
  maxPages: 'maxPages',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  uriType: 'uriType',
  allowedMimeTypes: 'allowedMimeTypes',
  excludePatterns: 'excludePatterns',
  includePatterns: 'includePatterns',
  maxFileSize: 'maxFileSize',
  minFileSize: 'minFileSize',
  crawlerConfig: 'crawlerConfig'
} as const

export type AiLibraryCrawlerScalarFieldEnum = (typeof AiLibraryCrawlerScalarFieldEnum)[keyof typeof AiLibraryCrawlerScalarFieldEnum]


export const AiLibraryCrawlerRunScalarFieldEnum = {
  id: 'id',
  crawlerId: 'crawlerId',
  startedAt: 'startedAt',
  endedAt: 'endedAt',
  success: 'success',
  runByUserId: 'runByUserId',
  runByCronJob: 'runByCronJob',
  errorMessage: 'errorMessage',
  stoppedByUser: 'stoppedByUser'
} as const

export type AiLibraryCrawlerRunScalarFieldEnum = (typeof AiLibraryCrawlerRunScalarFieldEnum)[keyof typeof AiLibraryCrawlerRunScalarFieldEnum]


export const AiLibraryCrawlerCronJobScalarFieldEnum = {
  id: 'id',
  active: 'active',
  hour: 'hour',
  minute: 'minute',
  monday: 'monday',
  tuesday: 'tuesday',
  wednesday: 'wednesday',
  thursday: 'thursday',
  friday: 'friday',
  saturday: 'saturday',
  sunday: 'sunday',
  crawlerId: 'crawlerId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AiLibraryCrawlerCronJobScalarFieldEnum = (typeof AiLibraryCrawlerCronJobScalarFieldEnum)[keyof typeof AiLibraryCrawlerCronJobScalarFieldEnum]


export const AiLibraryUpdateScalarFieldEnum = {
  id: 'id',
  libraryId: 'libraryId',
  fileId: 'fileId',
  crawlerRunId: 'crawlerRunId',
  message: 'message',
  createdAt: 'createdAt',
  fileName: 'fileName',
  filePath: 'filePath',
  fileSize: 'fileSize',
  filterType: 'filterType',
  filterValue: 'filterValue',
  updateType: 'updateType'
} as const

export type AiLibraryUpdateScalarFieldEnum = (typeof AiLibraryUpdateScalarFieldEnum)[keyof typeof AiLibraryUpdateScalarFieldEnum]


export const AiListScalarFieldEnum = {
  id: 'id',
  ownerId: 'ownerId',
  workspaceId: 'workspaceId',
  name: 'name',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AiListScalarFieldEnum = (typeof AiListScalarFieldEnum)[keyof typeof AiListScalarFieldEnum]


export const AiListSourceScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  listId: 'listId',
  libraryId: 'libraryId'
} as const

export type AiListSourceScalarFieldEnum = (typeof AiListSourceScalarFieldEnum)[keyof typeof AiListSourceScalarFieldEnum]


export const AiListItemScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  listId: 'listId',
  sourceId: 'sourceId',
  sourceFileId: 'sourceFileId',
  extractionIndex: 'extractionIndex',
  itemName: 'itemName',
  metadata: 'metadata'
} as const

export type AiListItemScalarFieldEnum = (typeof AiListItemScalarFieldEnum)[keyof typeof AiListItemScalarFieldEnum]


export const AiListFieldScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  listId: 'listId',
  name: 'name',
  type: 'type',
  order: 'order',
  sourceType: 'sourceType',
  fileProperty: 'fileProperty',
  prompt: 'prompt',
  failureTerms: 'failureTerms',
  languageModelId: 'languageModelId'
} as const

export type AiListFieldScalarFieldEnum = (typeof AiListFieldScalarFieldEnum)[keyof typeof AiListFieldScalarFieldEnum]


export const AiListFieldContextScalarFieldEnum = {
  id: 'id',
  fieldId: 'fieldId',
  contextType: 'contextType',
  contextFieldId: 'contextFieldId',
  contextQuery: 'contextQuery',
  maxContentTokens: 'maxContentTokens',
  createdAt: 'createdAt'
} as const

export type AiListFieldContextScalarFieldEnum = (typeof AiListFieldContextScalarFieldEnum)[keyof typeof AiListFieldContextScalarFieldEnum]


export const AiListItemCacheScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  itemId: 'itemId',
  fieldId: 'fieldId',
  valueString: 'valueString',
  valueNumber: 'valueNumber',
  valueDate: 'valueDate',
  valueBoolean: 'valueBoolean',
  enrichmentErrorMessage: 'enrichmentErrorMessage',
  failedEnrichmentValue: 'failedEnrichmentValue'
} as const

export type AiListItemCacheScalarFieldEnum = (typeof AiListItemCacheScalarFieldEnum)[keyof typeof AiListItemCacheScalarFieldEnum]


export const AiEnrichmentTaskScalarFieldEnum = {
  id: 'id',
  listId: 'listId',
  fieldId: 'fieldId',
  itemId: 'itemId',
  status: 'status',
  priority: 'priority',
  requestedAt: 'requestedAt',
  startedAt: 'startedAt',
  completedAt: 'completedAt',
  error: 'error',
  metadata: 'metadata'
} as const

export type AiEnrichmentTaskScalarFieldEnum = (typeof AiEnrichmentTaskScalarFieldEnum)[keyof typeof AiEnrichmentTaskScalarFieldEnum]


export const AiConversationScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  ownerId: 'ownerId',
  workspaceId: 'workspaceId'
} as const

export type AiConversationScalarFieldEnum = (typeof AiConversationScalarFieldEnum)[keyof typeof AiConversationScalarFieldEnum]


export const AiConversationParticipantScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  conversationId: 'conversationId',
  userId: 'userId',
  assistantId: 'assistantId'
} as const

export type AiConversationParticipantScalarFieldEnum = (typeof AiConversationParticipantScalarFieldEnum)[keyof typeof AiConversationParticipantScalarFieldEnum]


export const AiConversationMessageScalarFieldEnum = {
  id: 'id',
  sequenceNumber: 'sequenceNumber',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  senderId: 'senderId',
  content: 'content',
  source: 'source',
  conversationId: 'conversationId',
  hidden: 'hidden'
} as const

export type AiConversationMessageScalarFieldEnum = (typeof AiConversationMessageScalarFieldEnum)[keyof typeof AiConversationMessageScalarFieldEnum]


export const AiConversationInvitationScalarFieldEnum = {
  id: 'id',
  email: 'email',
  inviterId: 'inviterId',
  confirmedByEmail: 'confirmedByEmail',
  confirmationDate: 'confirmationDate',
  conversationId: 'conversationId',
  date: 'date',
  allowDifferentEmailAddress: 'allowDifferentEmailAddress',
  allowMultipleParticipants: 'allowMultipleParticipants',
  isUsed: 'isUsed',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AiConversationInvitationScalarFieldEnum = (typeof AiConversationInvitationScalarFieldEnum)[keyof typeof AiConversationInvitationScalarFieldEnum]


export const ApiKeyScalarFieldEnum = {
  id: 'id',
  name: 'name',
  keyHash: 'keyHash',
  libraryId: 'libraryId',
  userId: 'userId',
  createdAt: 'createdAt',
  lastUsedAt: 'lastUsedAt'
} as const

export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


export const AiLanguageModelScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  workspaceId: 'workspaceId',
  name: 'name',
  provider: 'provider',
  canDoEmbedding: 'canDoEmbedding',
  canDoChatCompletion: 'canDoChatCompletion',
  canDoVision: 'canDoVision',
  canDoFunctionCalling: 'canDoFunctionCalling',
  enabled: 'enabled',
  adminNotes: 'adminNotes',
  lastUsedAt: 'lastUsedAt'
} as const

export type AiLanguageModelScalarFieldEnum = (typeof AiLanguageModelScalarFieldEnum)[keyof typeof AiLanguageModelScalarFieldEnum]


export const AiModelUsageScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  modelId: 'modelId',
  userId: 'userId',
  libraryId: 'libraryId',
  assistantId: 'assistantId',
  listId: 'listId',
  usageType: 'usageType',
  tokensInput: 'tokensInput',
  tokensOutput: 'tokensOutput',
  requestCount: 'requestCount',
  durationMs: 'durationMs'
} as const

export type AiModelUsageScalarFieldEnum = (typeof AiModelUsageScalarFieldEnum)[keyof typeof AiModelUsageScalarFieldEnum]


export const AiConnectorTypeWorkspaceScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  workspaceId: 'workspaceId',
  connectorType: 'connectorType'
} as const

export type AiConnectorTypeWorkspaceScalarFieldEnum = (typeof AiConnectorTypeWorkspaceScalarFieldEnum)[keyof typeof AiConnectorTypeWorkspaceScalarFieldEnum]


export const AiConnectorScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  workspaceId: 'workspaceId',
  connectorType: 'connectorType',
  baseUrl: 'baseUrl',
  name: 'name',
  config: 'config',
  isConnected: 'isConnected',
  lastTestedAt: 'lastTestedAt',
  lastError: 'lastError'
} as const

export type AiConnectorScalarFieldEnum = (typeof AiConnectorScalarFieldEnum)[keyof typeof AiConnectorScalarFieldEnum]


export const AiAutomationScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  workspaceId: 'workspaceId',
  name: 'name',
  listId: 'listId',
  connectorId: 'connectorId',
  connectorAction: 'connectorAction',
  connectorActionConfig: 'connectorActionConfig',
  filter: 'filter',
  schedule: 'schedule',
  executeOnEnrichment: 'executeOnEnrichment'
} as const

export type AiAutomationScalarFieldEnum = (typeof AiAutomationScalarFieldEnum)[keyof typeof AiAutomationScalarFieldEnum]


export const AiAutomationItemScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  automationId: 'automationId',
  listItemId: 'listItemId',
  inScope: 'inScope',
  status: 'status'
} as const

export type AiAutomationItemScalarFieldEnum = (typeof AiAutomationItemScalarFieldEnum)[keyof typeof AiAutomationItemScalarFieldEnum]


export const AiAutomationItemExecutionScalarFieldEnum = {
  id: 'id',
  automationItemId: 'automationItemId',
  batchId: 'batchId',
  status: 'status',
  input: 'input',
  output: 'output',
  startedAt: 'startedAt',
  finishedAt: 'finishedAt'
} as const

export type AiAutomationItemExecutionScalarFieldEnum = (typeof AiAutomationItemExecutionScalarFieldEnum)[keyof typeof AiAutomationItemExecutionScalarFieldEnum]


export const AiAutomationBatchScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  automationId: 'automationId',
  status: 'status',
  triggeredBy: 'triggeredBy',
  itemsTotal: 'itemsTotal',
  itemsProcessed: 'itemsProcessed',
  itemsSuccess: 'itemsSuccess',
  itemsWarning: 'itemsWarning',
  itemsFailed: 'itemsFailed',
  itemsSkipped: 'itemsSkipped',
  startedAt: 'startedAt',
  finishedAt: 'finishedAt'
} as const

export type AiAutomationBatchScalarFieldEnum = (typeof AiAutomationBatchScalarFieldEnum)[keyof typeof AiAutomationBatchScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'AiListFieldContextType'
 */
export type EnumAiListFieldContextTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AiListFieldContextType'>
    


/**
 * Reference to a field of type 'AiListFieldContextType[]'
 */
export type ListEnumAiListFieldContextTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AiListFieldContextType[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'BigInt'
 */
export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


/**
 * Reference to a field of type 'BigInt[]'
 */
export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


/**
 * Reference to a field of type 'AutomationItemStatus'
 */
export type EnumAutomationItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationItemStatus'>
    


/**
 * Reference to a field of type 'AutomationItemStatus[]'
 */
export type ListEnumAutomationItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutomationItemStatus[]'>
    


/**
 * Reference to a field of type 'BatchStatus'
 */
export type EnumBatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BatchStatus'>
    


/**
 * Reference to a field of type 'BatchStatus[]'
 */
export type ListEnumBatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BatchStatus[]'>
    


/**
 * Reference to a field of type 'TriggerType'
 */
export type EnumTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerType'>
    


/**
 * Reference to a field of type 'TriggerType[]'
 */
export type ListEnumTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerType[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  user?: Prisma.UserOmit
  userProfile?: Prisma.UserProfileOmit
  workspace?: Prisma.WorkspaceOmit
  workspaceMember?: Prisma.WorkspaceMemberOmit
  workspaceInvitation?: Prisma.WorkspaceInvitationOmit
  aiServiceProvider?: Prisma.AiServiceProviderOmit
  aiAssistant?: Prisma.AiAssistantOmit
  aiAssistantBaseCase?: Prisma.AiAssistantBaseCaseOmit
  aiAssistantEUActAnswers?: Prisma.AiAssistantEUActAnswersOmit
  aiLibrary?: Prisma.AiLibraryOmit
  aiLibraryUsage?: Prisma.AiLibraryUsageOmit
  aiLibraryFile?: Prisma.AiLibraryFileOmit
  aiContentProcessingTask?: Prisma.AiContentProcessingTaskOmit
  aiContentExtractionSubTask?: Prisma.AiContentExtractionSubTaskOmit
  aiLibraryCrawler?: Prisma.AiLibraryCrawlerOmit
  aiLibraryCrawlerRun?: Prisma.AiLibraryCrawlerRunOmit
  aiLibraryCrawlerCronJob?: Prisma.AiLibraryCrawlerCronJobOmit
  aiLibraryUpdate?: Prisma.AiLibraryUpdateOmit
  aiList?: Prisma.AiListOmit
  aiListSource?: Prisma.AiListSourceOmit
  aiListItem?: Prisma.AiListItemOmit
  aiListField?: Prisma.AiListFieldOmit
  aiListFieldContext?: Prisma.AiListFieldContextOmit
  aiListItemCache?: Prisma.AiListItemCacheOmit
  aiEnrichmentTask?: Prisma.AiEnrichmentTaskOmit
  aiConversation?: Prisma.AiConversationOmit
  aiConversationParticipant?: Prisma.AiConversationParticipantOmit
  aiConversationMessage?: Prisma.AiConversationMessageOmit
  aiConversationInvitation?: Prisma.AiConversationInvitationOmit
  apiKey?: Prisma.ApiKeyOmit
  aiLanguageModel?: Prisma.AiLanguageModelOmit
  aiModelUsage?: Prisma.AiModelUsageOmit
  aiConnectorTypeWorkspace?: Prisma.AiConnectorTypeWorkspaceOmit
  aiConnector?: Prisma.AiConnectorOmit
  aiAutomation?: Prisma.AiAutomationOmit
  aiAutomationItem?: Prisma.AiAutomationItemOmit
  aiAutomationItemExecution?: Prisma.AiAutomationItemExecutionOmit
  aiAutomationBatch?: Prisma.AiAutomationBatchOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

