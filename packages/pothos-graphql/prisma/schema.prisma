// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider        = "prisma-client"
  previewFeatures = ["typedSql"]
  output          = "./generated"
}

generator pothos {
  provider = "prisma-pothos-types"
  output   = "../node_modules/.pothos/plugin-prisma/generated.ts"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                         String                      @id @default(cuid())
  createdAt                  DateTime                    @default(now())
  updatedAt                  DateTime                    @updatedAt
  lastLogin                  DateTime?
  email                      String                      @unique
  username                   String                      @unique
  name                       String?
  given_name                 String?
  family_name                String?
  avatarUrl                  String?
  isAdmin                    Boolean                     @default(false)
  assistants                 AiAssistant[]
  libraries                  AiLibrary[]
  assistantParticipations    AiAssistantParticipant[]
  libraryParticipations      AiLibraryParticipant[]
  conversationParticipations AiConversationParticipant[]
  profile                    UserProfile?
  conversations              AiConversation[]
  crawlerRuns                AiLibraryCrawlerRun[]
  conversationInvitation     AiConversationInvitation[]
  lists                      AiList[]
  listParticipations         AiListParticipant[]
}

model UserProfile {
  id               String    @id @default(cuid())
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  expiresAt        DateTime?
  email            String
  firstName        String?
  lastName         String?
  freeMessages     Int       @default(20)
  freeStorage      Int       @default(100000)
  business         String?
  position         String?
  user             User      @relation(fields: [userId], references: [id])
  userId           String    @unique
  confirmationDate DateTime?
  activationDate   DateTime?
}

model AiAssistant {
  id                         String                      @id @default(cuid())
  createdAt                  DateTime                    @default(now())
  updatedAt                  DateTime                    @updatedAt
  name                       String
  description                String?
  url                        String?
  iconUrl                    String?
  owner                      User                        @relation(fields: [ownerId], references: [id])
  ownerId                    String
  usages                     AiLibraryUsage[]
  participants               AiAssistantParticipant[]
  conversationParticipations AiConversationParticipant[]
  languageModel              String?                     @default("OpenAI")
  baseCases                  AiAssistantBaseCase[]
  euActAnswers               AiAssistantEUActAnswers[]
}

model AiAssistantBaseCase {
  id          String      @id @default(cuid())
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  assistant   AiAssistant @relation(fields: [assistantId], references: [id], onDelete: Cascade)
  sequence    Int
  assistantId String
  condition   String?
  instruction String?
}

model AiAssistantEUActAnswers {
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  assistant   AiAssistant @relation(fields: [assistantId], references: [id], onDelete: Cascade)
  assistantId String
  questionId  String
  answer      String?
  notes       String?

  @@id([assistantId, questionId])
}

model AiAssistantParticipant {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  assistantId String
  userId      String

  assistant AiAssistant @relation(fields: [assistantId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([assistantId, userId])
}

model AiLibrary {
  id                   String                 @id @default(cuid())
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  name                 String
  description          String?
  url                  String?
  apiToken             String?
  lastProcessed        DateTime?
  owner                User                   @relation(fields: [ownerId], references: [id])
  ownerId              String
  isPublic             Boolean                @default(true)
  embeddingModelName   String?
  embeddingTimeoutMs   Int?                   @default(180000) // Default 3 minutes for embedding tasks
  fileConverterOptions String?
  usages               AiLibraryUsage[]
  files                AiLibraryFile[]
  crawlers             AiLibraryCrawler[]
  participants         AiLibraryParticipant[]

  updates     AiLibraryUpdate[]
  listSources AiListSource[]

  contentExtractionTasks AiContentProcessingTask[]
}

model AiLibraryUsage {
  id          String      @id @default(cuid())
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @default(now()) @updatedAt
  assistant   AiAssistant @relation(fields: [assistantId], references: [id], onDelete: Cascade)
  assistantId String
  library     AiLibrary   @relation(fields: [libraryId], references: [id], onDelete: Cascade)
  libraryId   String
  usedFor     String?

  @@unique([assistantId, libraryId])
}

model AiLibraryFile {
  id                     String                    @id @default(cuid())
  createdAt              DateTime                  @default(now())
  updatedAt              DateTime                  @updatedAt
  library                AiLibrary                 @relation(fields: [libraryId], references: [id])
  libraryId              String
  name                   String
  originUri              String?
  docPath                String?
  mimeType               String
  size                   Int?
  uploadedAt             DateTime?
  dropError              String?
  crawledByCrawlerId     String?
  crawledByCrawler       AiLibraryCrawler?         @relation(fields: [crawledByCrawlerId], references: [id])
  originFileHash         String?
  originModificationDate DateTime?
  archivedAt             DateTime?
  updates                AiLibraryUpdate[]
  cache                  AiListItemCache[]
  enrichmentTasks        AiEnrichmentTask[]
  contentExtractionTasks AiContentProcessingTask[]

  @@unique([crawledByCrawlerId, originUri])
}

model AiContentProcessingTask {
  id        String @id @default(cuid())
  fileId    String
  libraryId String

  createdAt DateTime @default(now()) // When task was submitted

  library AiLibrary     @relation(fields: [libraryId], references: [id], onDelete: Cascade)
  file    AiLibraryFile @relation(fields: [fileId], references: [id], onDelete: Cascade)

  // Configuration options
  timeoutMs          Int? // Override library default timeout for this task
  embeddingModelName String?
  extractionOptions  String? // Validated JSON per method schema

  // Processing phase timestamps
  processingStartedAt  DateTime? // When worker picks up task (start of entire pipeline)
  processingFinishedAt DateTime? // When entire pipeline completes (success/fail/timeout)
  processingFailedAt   DateTime? // Infrastructure timeout (worker stuck, not legitimate long processing)
  processingCancelled  Boolean   @default(false) // User-requested cancellation
  processingTimeout    Boolean   @default(false)

  // Extraction phase timestamps
  extractionStartedAt  DateTime? // Set only after validation passes
  extractionFinishedAt DateTime?
  extractionFailedAt   DateTime?
  extractionTimeout    Boolean   @default(false)

  // Embedding phase timestamps
  embeddingStartedAt  DateTime?
  embeddingFinishedAt DateTime?
  embeddingFailedAt   DateTime?
  embeddingTimeout    Boolean   @default(false)

  // Result data
  chunksCount Int?
  chunksSize  Int? // Total size of all chunks
  metadata    String? // Method-specific results & confidence scoring

  extractionSubTasks AiContentExtractionSubTask[]

  @@index([fileId, extractionStartedAt])
  @@index([libraryId, fileId, extractionStartedAt])
}

model AiContentExtractionSubTask {
  id                      String                  @id @default(cuid())
  createdAt               DateTime                @default(now()) // When task was submitted
  startedAt               DateTime? // When worker picks up task
  finishedAt              DateTime? // When task completes (success/fail/timeout)
  failedAt                DateTime? // Infrastructure timeout (worker stuck, not legitimate long processing)
  contentProcessingTaskId String
  contentProcessingTask   AiContentProcessingTask @relation(fields: [contentProcessingTaskId], references: [id], onDelete: Cascade)
  extractionMethod        String // "text-extraction", "pdf-image-llm", "tesseract-ocr", "embedding-only"
  markdownFileName        String?

  @@index([contentProcessingTaskId])
  @@index([extractionMethod, startedAt])
}

model AiLibraryCrawler {
  id               String                   @id @default(cuid())
  uriType          String
  uri              String
  libraryId        String
  lastRun          DateTime?
  maxDepth         Int
  maxPages         Int
  // File filtering configuration
  includePatterns  String? // JSON array of regex patterns to include (if empty, include all)
  excludePatterns  String? // JSON array of regex patterns to exclude
  maxFileSize      Int? // Maximum file size in bytes
  minFileSize      Int? // Minimum file size in bytes
  allowedMimeTypes String? // JSON array of allowed MIME types (if empty, allow all)
  createdAt        DateTime                 @default(now())
  updatedAt        DateTime                 @updatedAt
  library          AiLibrary                @relation(fields: [libraryId], references: [id])
  runs             AiLibraryCrawlerRun[]
  files            AiLibraryFile[]
  cronJob          AiLibraryCrawlerCronJob?
}

model AiLibraryCrawlerRun {
  id            String            @id @default(cuid())
  crawlerId     String
  startedAt     DateTime          @default(now())
  endedAt       DateTime?
  success       Boolean?
  errorMessage  String?
  runByUserId   String?
  runByCronJob  Boolean           @default(false)
  stoppedByUser DateTime?
  crawler       AiLibraryCrawler  @relation(fields: [crawlerId], references: [id], onDelete: Cascade)
  runBy         User?             @relation(fields: [runByUserId], references: [id])
  updates       AiLibraryUpdate[]
}

model AiLibraryCrawlerCronJob {
  id        String   @id @default(cuid())
  active    Boolean  @default(true)
  hour      Int      @default(0)
  minute    Int      @default(0)
  monday    Boolean  @default(true)
  tuesday   Boolean  @default(true)
  wednesday Boolean  @default(true)
  thursday  Boolean  @default(true)
  friday    Boolean  @default(true)
  saturday  Boolean  @default(true)
  sunday    Boolean  @default(true)
  crawlerId String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  crawler AiLibraryCrawler @relation(fields: [crawlerId], references: [id], onDelete: Cascade)
}

model AiLibraryUpdate {
  id           String               @id @default(cuid())
  libraryId    String
  fileId       String?
  crawlerRunId String?
  message      String?
  updateType   String               @default("added") // 'added', 'updated', 'omitted', 'error'
  // Fields for omitted files (when fileId is null)
  filePath     String? // Full path for omitted files
  fileName     String? // File name for omitted files  
  fileSize     Int? // File size for omitted files
  filterType   String? // Type of filter that caused omission
  filterValue  String? // Actual filter value that matched
  createdAt    DateTime             @default(now())
  library      AiLibrary            @relation(fields: [libraryId], references: [id], onDelete: Cascade)
  crawlerRun   AiLibraryCrawlerRun? @relation(fields: [crawlerRunId], references: [id], onDelete: Cascade)
  file         AiLibraryFile?       @relation(fields: [fileId], references: [id], onDelete: Cascade)
}

model AiLibraryParticipant {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  libraryId String
  userId    String
  library   AiLibrary @relation(fields: [libraryId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([libraryId, userId])
}

model AiList {
  id              String              @id @default(cuid())
  ownerId         String
  name            String
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  owner           User                @relation(fields: [ownerId], references: [id])
  participants    AiListParticipant[]
  fields          AiListField[]
  sources         AiListSource[]
  enrichmentTasks AiEnrichmentTask[]
}

model AiListSource {
  id        String     @id @default(cuid())
  createdAt DateTime   @default(now())
  listId    String
  list      AiList     @relation(fields: [listId], references: [id])
  libraryId String?
  library   AiLibrary? @relation(fields: [libraryId], references: [id])
}

model AiListParticipant {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  listId    String
  userId    String
  list      AiList   @relation(fields: [listId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([listId, userId])
}

model AiListField {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  listId    String
  name      String
  type      String // 'text', 'number', 'date', 'datetime', 'boolean'
  order     Int      @default(0) // Display order in table

  // Source configuration
  sourceType String // 'file_property' or 'llm_computed'

  // For file_property source
  fileProperty String? // 'name', 'originUri', 'processedAt', 'originModificationDate', 'size', 'mimeType', 'crawlerUrl'

  // For llm_computed source
  languageModel  String?
  prompt         String?
  contentQuery   String? // Query for vector store search when useVectorStore is true
  useVectorStore Boolean?
  failureTerms   String? // Comma-separated list of terms that indicate failure in LLM response

  list            AiList               @relation(fields: [listId], references: [id], onDelete: Cascade)
  cachedValues    AiListItemCache[]
  enrichmentTasks AiEnrichmentTask[]
  context         AiListFieldContext[] @relation("fieldId")
  usedAsContext   AiListFieldContext[] @relation("contextFieldId")
}

model AiListFieldContext {
  fieldId        String
  field          AiListField @relation("fieldId", fields: [fieldId], references: [id], onDelete: Cascade)
  contextFieldId String
  contextField   AiListField @relation("contextFieldId", fields: [contextFieldId], references: [id], onDelete: Cascade)
  createdAt      DateTime    @default(now())

  @@id([fieldId, contextFieldId])
}

model AiListItemCache {
  id                     String        @id @default(cuid())
  createdAt              DateTime      @default(now())
  updatedAt              DateTime      @updatedAt
  fileId                 String
  fieldId                String
  valueString            String?
  valueNumber            Float?
  valueDate              DateTime?
  valueBoolean           Boolean?
  enrichmentErrorMessage String? // Store enrichment errors
  failedEnrichmentValue  String? // Store the value if it matched failureTerms (not stored in value* fields)
  file                   AiLibraryFile @relation(fields: [fileId], references: [id], onDelete: Cascade)
  field                  AiListField   @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  @@unique([fileId, fieldId])
}

model AiEnrichmentTask {
  id          String        @id @default(cuid())
  listId      String
  fieldId     String
  fileId      String
  status      String // 'pending', 'processing', 'completed', 'failed'
  priority    Int           @default(0) // Higher number = higher priority
  requestedAt DateTime      @default(now())
  startedAt   DateTime?
  completedAt DateTime?
  metadata    String? // JSON blob for method-specific data
  error       String?
  list        AiList        @relation(fields: [listId], references: [id], onDelete: Cascade)
  field       AiListField   @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  file        AiLibraryFile @relation(fields: [fileId], references: [id], onDelete: Cascade)

  @@unique([listId, fieldId, fileId])
  @@index([listId, status])
  @@index([status, priority, requestedAt])
}

model AiConversation {
  id                      String                      @id @default(cuid())
  ownerId                 String
  createdAt               DateTime                    @default(now())
  updatedAt               DateTime                    @updatedAt
  messages                AiConversationMessage[]
  participants            AiConversationParticipant[]
  owner                   User                        @relation(fields: [ownerId], references: [id])
  conversationInvitations AiConversationInvitation[]
}

model AiConversationParticipant {
  id                  String                  @id @default(cuid())
  createdAt           DateTime                @default(now())
  conversationId      String
  userId              String?
  assistantId         String?
  conversation        AiConversation          @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user                User?                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  assistant           AiAssistant?            @relation(fields: [assistantId], references: [id], onDelete: Cascade)
  conversationMessage AiConversationMessage[]
}

model AiConversationMessage {
  id             String                    @id @default(cuid())
  sequenceNumber BigInt                    @default(autoincrement())
  createdAt      DateTime                  @default(now())
  updatedAt      DateTime                  @updatedAt
  sender         AiConversationParticipant @relation(fields: [senderId], references: [id], onDelete: Cascade)
  senderId       String
  content        String
  source         String?
  hidden         Boolean                   @default(false)
  conversation   AiConversation            @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId String
}

model AiConversationInvitation {
  id                         String         @id @default(cuid())
  email                      String
  inviterId                  String
  confirmedByEmail           String?
  confirmationDate           DateTime?
  conversationId             String
  date                       DateTime       @default(now())
  allowDifferentEmailAddress Boolean        @default(false)
  allowMultipleParticipants  Boolean        @default(false)
  isUsed                     Boolean        @default(false)
  createdAt                  DateTime       @default(now())
  updatedAt                  DateTime       @updatedAt
  inviter                    User           @relation(fields: [inviterId], references: [id], onDelete: Cascade)
  conversation               AiConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
}
