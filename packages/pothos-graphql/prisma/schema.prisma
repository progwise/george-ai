// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider        = "prisma-client-js"
  binaryTargets   = ["native", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-3.0.x"]
  previewFeatures = []
  output          = "../node_modules/@george-ai/prismaClient"
}

generator pothos {
  provider = "prisma-pothos-types"
  output   = "../node_modules/.pothos/plugin-prisma/generated.ts"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                         String                      @id @default(cuid())
  createdAt                  DateTime                    @default(now())
  updatedAt                  DateTime                    @updatedAt
  lastLogin                  DateTime?
  email                      String                      @unique
  username                   String                      @unique
  name                       String?
  given_name                 String?
  family_name                String?
  avatarUrl                  String?
  isAdmin                    Boolean                     @default(false)
  assistants                 AiAssistant[]
  libraries                  AiLibrary[]
  assistantParticipations    AiAssistantParticipant[]
  libraryParticipations      AiLibraryParticipant[]
  conversationParticipations AiConversationParticipant[]
  profile                    UserProfile?
  conversations              AiConversation[]
  crawlerRuns                AiLibraryCrawlerRun[]
  conversationInvitation     AiConversationInvitation[]
}

model UserProfile {
  id               String    @id @default(cuid())
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  expiresAt        DateTime?
  email            String
  firstName        String?
  lastName         String?
  freeMessages     Int       @default(20)
  freeStorage      Int       @default(100000)
  business         String?
  position         String?
  user             User      @relation(fields: [userId], references: [id])
  userId           String    @unique
  confirmationDate DateTime?
  activationDate   DateTime?
}

model AiAssistant {
  id                         String                      @id @default(cuid())
  createdAt                  DateTime                    @default(now())
  updatedAt                  DateTime                    @updatedAt
  name                       String
  description                String?
  url                        String?
  iconUrl                    String?
  owner                      User                        @relation(fields: [ownerId], references: [id])
  ownerId                    String
  usages                     AiLibraryUsage[]
  participants               AiAssistantParticipant[]
  conversationParticipations AiConversationParticipant[]
  languageModel              String?                     @default("OpenAI")
  baseCases                  AiAssistantBaseCase[]

  AiAssistantEUActAnswers AiAssistantEUActAnswers[]
}

model AiAssistantBaseCase {
  id          String      @id @default(cuid())
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  assistant   AiAssistant @relation(fields: [assistantId], references: [id], onDelete: Cascade)
  sequence    Int
  assistantId String
  condition   String?
  instruction String?
}

model AiAssistantEUActAnswers {
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  assistant   AiAssistant @relation(fields: [assistantId], references: [id], onDelete: Cascade)
  assistantId String
  questionId  String
  answer      String?
  notes       String?

  @@id([assistantId, questionId])
}

model AiAssistantParticipant {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  assistantId String
  userId      String

  assistant AiAssistant @relation(fields: [assistantId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([assistantId, userId])
}

model AiLibrary {
  id                    String                 @id @default(cuid())
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  name                  String
  description           String?
  url                   String?
  apiToken              String?
  lastProcessed         DateTime?
  owner                 User                   @relation(fields: [ownerId], references: [id])
  ownerId               String
  isPublic              Boolean                @default(true)
  embeddingModelName    String?
  fileProcessingOptions String?
  usages                AiLibraryUsage[]
  files                 AiLibraryFile[]
  crawlers              AiLibraryCrawler[]
  participants          AiLibraryParticipant[]

  AiLibraryUpdate AiLibraryUpdate[]
}

model AiLibraryUsage {
  id          String      @id @default(cuid())
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @default(now()) @updatedAt
  assistant   AiAssistant @relation(fields: [assistantId], references: [id], onDelete: Cascade)
  assistantId String
  library     AiLibrary   @relation(fields: [libraryId], references: [id], onDelete: Cascade)
  libraryId   String
  usedFor     String?

  @@unique([assistantId, libraryId])
}

model AiLibraryFile {
  id                     String            @id @default(cuid())
  createdAt              DateTime          @default(now())
  updatedAt              DateTime          @updatedAt
  library                AiLibrary         @relation(fields: [libraryId], references: [id])
  libraryId              String
  name                   String
  originUri              String?
  docPath                String?
  mimeType               String
  size                   Int?
  chunks                 Int?
  uploadedAt             DateTime?
  processedAt            DateTime?
  dropError              String?
  processingStartedAt    DateTime?
  processingEndedAt      DateTime?
  processingErrorAt      DateTime?
  processingErrorMessage String?
  crawledByCrawlerId     String?
  crawledByCrawler       AiLibraryCrawler? @relation(fields: [crawledByCrawlerId], references: [id])
  AiLibraryUpdate        AiLibraryUpdate[]

  @@unique([crawledByCrawlerId, originUri])
}

model AiLibraryCrawler {
  id        String    @id @default(cuid())
  url       String
  libraryId String
  lastRun   DateTime?
  maxDepth  Int
  maxPages  Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  library AiLibrary                @relation(fields: [libraryId], references: [id])
  runs    AiLibraryCrawlerRun[]
  files   AiLibraryFile[]
  cronJob AiLibraryCrawlerCronJob?
}

model AiLibraryCrawlerRun {
  id            String    @id @default(cuid())
  crawlerId     String
  startedAt     DateTime  @default(now())
  endedAt       DateTime?
  success       Boolean?
  errorMessage  String?
  pagesCrawled  Int?
  runByUserId   String?
  runByCronJob  Boolean   @default(false)
  stoppedByUser DateTime?

  crawler AiLibraryCrawler @relation(fields: [crawlerId], references: [id], onDelete: Cascade)
  runBy   User?            @relation(fields: [runByUserId], references: [id])

  updates AiLibraryUpdate[]
}

model AiLibraryCrawlerCronJob {
  id        String  @id @default(cuid())
  active    Boolean @default(true)
  hour      Int     @default(0)
  minute    Int     @default(0)
  monday    Boolean @default(true)
  tuesday   Boolean @default(true)
  wednesday Boolean @default(true)
  thursday  Boolean @default(true)
  friday    Boolean @default(true)
  saturday  Boolean @default(true)
  sunday    Boolean @default(true)
  crawlerId String  @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  crawler AiLibraryCrawler @relation(fields: [crawlerId], references: [id], onDelete: Cascade)
}

model AiLibraryUpdate {
  id           String   @id @default(cuid())
  libraryId    String
  fileId       String?
  crawlerRunId String?
  success      Boolean
  message      String?
  createdAt    DateTime @default(now())

  library    AiLibrary            @relation(fields: [libraryId], references: [id], onDelete: Cascade)
  crawlerRun AiLibraryCrawlerRun? @relation(fields: [crawlerRunId], references: [id], onDelete: Cascade)
  file       AiLibraryFile?       @relation(fields: [fileId], references: [id], onDelete: Cascade)
}

model AiLibraryParticipant {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  libraryId String
  userId    String

  library AiLibrary @relation(fields: [libraryId], references: [id], onDelete: Cascade)
  user    User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([libraryId, userId])
}

model AiConversation {
  id      String @id @default(cuid())
  ownerId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages                AiConversationMessage[]
  participants            AiConversationParticipant[]
  owner                   User                        @relation(fields: [ownerId], references: [id])
  conversationInvitations AiConversationInvitation[]
}

model AiConversationParticipant {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())
  conversationId String
  userId         String?
  assistantId    String?

  conversation        AiConversation          @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user                User?                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  assistant           AiAssistant?            @relation(fields: [assistantId], references: [id], onDelete: Cascade)
  conversationMessage AiConversationMessage[]
}

model AiConversationMessage {
  id             String                    @id @default(cuid())
  sequenceNumber BigInt                    @default(autoincrement())
  createdAt      DateTime                  @default(now())
  updatedAt      DateTime                  @updatedAt
  sender         AiConversationParticipant @relation(fields: [senderId], references: [id], onDelete: Cascade)
  senderId       String
  content        String
  source         String?
  hidden         Boolean                   @default(false)
  conversation   AiConversation            @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId String
}

model AiConversationInvitation {
  id                         String    @id @default(cuid())
  email                      String
  inviterId                  String
  confirmedByEmail           String?
  confirmationDate           DateTime?
  conversationId             String
  date                       DateTime  @default(now())
  allowDifferentEmailAddress Boolean   @default(false)
  allowMultipleParticipants  Boolean   @default(false)
  isUsed                     Boolean   @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  inviter      User           @relation(fields: [inviterId], references: [id], onDelete: Cascade)
  conversation AiConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
}
